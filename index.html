<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="LJ" />
  

  
  
  
  
  
  
  <title>孤狼的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="LJ">
<meta property="og:type" content="website">
<meta property="og:title" content="孤狼的技术博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="孤狼的技术博客">
<meta property="og:description" content="LJ">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孤狼的技术博客">
<meta name="twitter:description" content="LJ">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="孤狼的技术博客" rel="home">孤狼的技术博客</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">西伯利亚的嗜血狼王</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main">
  
    <article id="post-ios-xmpp协议" class="post-ios-xmpp协议 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2016/02/13/ios-xmpp协议/">ios-xmpp协议</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2016/02/13/ios-xmpp协议/" data-id="ciq0acdu500008as6h4073q5b" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>什么是OpenFire<br>Openfire 采用Java开发，开源的实时协作（RTC）服务器基于XMPP（Jabber）协议。<br>　　您可以使用它轻易的构建高效率的即时通信服务器。Openfire安装和使用都非常简单，并利用Web进行管理。单台服务器可支持上万并发用户。</p>
<p>由于是采用开放的XMPP协议，您可以使用各种支持XMPP协议的IM客户端软件登陆服务。<br>XMPP（Jabber）协议</p>
<p>1、 介绍<br>XMPP是一种基于XML的协议，它继承了在XML环境中灵活的发展性。因此，基于XMPP的应用具有超强的可扩展性。经过扩展以后的XMPP可以通过发送扩展的信息来处理用户的需求，以及在XMPP的顶端建立如内容发布系统和基于地址的服务等应用程 序。而且，XMPP包含了针对服务器端的软件协议，使之能与另一个进行通话，这使得开发者更容易建立客户应用程序或给一个配好系统添加功能。</p>
<p>2、 定义：<br>XMPP（可扩展消息处理现场协议）是基于可扩展标记语言（XML）的协议，它用于即时消息（IM）以及在线现场探测。它在促进服务器之间的准即时操作。这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。<br>XMPP的前身是Jabber， 一个开源形式组织产生的网络即时通信协议。XMPP目前被IETF国际标准组织完成了标准化工作。标准化的核心结果分为两部分；</p>
<p>核心的XML流传输协议<br>基于XML FreeEIM流传输的即时通讯扩展应用<br>XMPP的核心XML流传输协议的定义使得XMPP能够在一个比以往网络通信协议更规范的平台上。借助于XML易于解析和阅读的特性，使得XMPP的协议能够非常漂亮。<br>XMPP的即时通讯扩展应用部分是根据IETF在这之前对即时通讯的一个抽象定义的，与其他业已得到广泛使用的即时通讯协议，诸如AIM，QQ等有功能完整，完善等先进性。<br>在IETF 中，把IM协议划分为四种协议，即时信息和出席协议(Instant Messaging and Presence Protocol, IMPP)、出席和即时信息协议(Presence and Instant Messaging Protocol, PRIM)、针对即时信息和出席扩展的会话发起协议(Session Initiation Protocol for Instant Messaging and Presence Leveraging Extensions, SIMPLE)，以及可扩展的消息出席协议(XMPP)。最初研发IMPP 也是为了创建一种标准化的协议，但是今天，IMPP 已经发展成为基本协议单元，定义所有即时通信协议应该支持的核心功能集。</p>
<p>3、 XMPP协议的优点<br>a. XMPP 协议是公开的，由JSF开源社区组织开发的。XMPP 协议并不属于任何的机构和个人，而是属于整个社区，这一点从根本上保证了其开放性。</p>
<p>b. XMPP 协议具有良好的扩展性。在XMPP 中，即时消息和到场信息都是基于XML 的结构化信息，这些信息以XML 节(XML Stanza)的形式在通信实体间交换。XMPP 发挥了XML 结构化数据的通用传输层的作用，它将出席和上下文敏感信息嵌入到XML 结构化数据中，从而使数据以极高的效率传送给最合适的资源。基于XML 建立起来的应用具有良好的语义完整性和扩展性。</p>
<p>c. 分布式的网络架构。XMPP 协议都是基于Client/Server 架构，但是XMPP协议本身并没有这样的限制。网络的架构和电子邮件十分相似，但没有结合任何特定的网络架构，适用范围非常广泛。</p>
<p>d. XMPP 具有很好的弹性。XMPP 除了可用在即时通信的应用程序，还能用在网络管理、内容供稿、协同工具、档案共享、游戏、远端系统监控等。</p>
<p>e. 安全性。XMPP在Client-to-Server通信，和Server-to-Server通信中都使用TLS (Transport Layer Security)协议作为通信通道的加密方法，保证通信的安全。任何XMPP服务器可以独立于公众XMPP网络（例如在企业内部网络中），而使用SASL及TLS等技术更加增强了通信的安全性。如下图所示：</p>
<p>4、 XMPP协议的组成<br>主要的XMPP 协议范本及当今应用很广的XMPP 扩展：<br>l RFC 3920 XMPP（新的RFC6120）：核心。定义了XMPP 协议框架下应用的网络架构，引入了XML Stream（XML 流）与XML Stanza（XML 节），并规定XMPP 协议在通信过程中使用的XML 标签。使用XML 标签从根本上说是协议开放性与扩展性的需要。此外，在通信的安全方面，把TLS 安全传输机制与SASL 认证机制引入到内核，与XMPP 进行无缝的连接，为协议的安全性、可靠性奠定了基础。Core 文档还规定了错误的定义及处理、XML 的使用规范、JID（Jabber Identifier，Jabber 标识符）的定义、命名规范等等。所以这是所有基于XMPP 协议的应用都必需支持的文档。</p>
<p>l RFC 3921：用户成功登陆到服务器之后，发布更新自己的在线好友管理、发送即时聊天消息等业务。所有的这些业务都是通过三种基本的XML 节来完成的：IQ Stanza（IQ 节）, Presence Stanza（Presence 节）, Message Stanza（Message 节）。RFC3921 还对阻塞策略进行了定义，定义是多种阻塞方式。可以说，RFC3921 是RFC3920 的充分补充。两个文档结合起来，就形成了一个基本的即时通信协议平台，在这个平台上可以开发出各种各样的应用。</p>
<p>l XEP-0030 服务搜索。一个强大的用来测定XMPP 网络中的其它实体所支持特性的协议。<br>l XEP-0115 实体性能。XEP-0030 的一个通过即时出席的定制，可以实时改变交变广告功能。<br>l XEP-0045 多人聊天。一组定义参与和管理多用户聊天室的协议，类似于Internet 的Relay Chat，具有很高的安全性。<br>l XEP-0096 文件传输。定义了从一个XMPP 实体到另一个的文件传输。<br>l XEP-0124 HTTP 绑定。将XMPP 绑定到HTTP 而不是TCP，主要用于不能够持久的维持与服务器TCP 连接的设备。<br>l XEP-0166 Jingle。规定了多媒体通信协商的整体架构。<br>l XEP-0167 Jingle Audio Content Description Format。定义了从一个XMPP 实体到另一个的语音传输过程。<br>l XEP-0176 Jingle ICE（Interactive Connectivity Establishment）Transport。ICE传输机制，文件解决了如何让防火墙或是NAT（Network Address Translation）保护下的实体建立连接的问题。<br>l XEP-0177 Jingle Raw UDP Transport。纯UDP 传输机制，文件讲述了如何在没有防火墙且在同一网络下建立连接的。<br>l XEP-0180 Jingle Video Content Description Format。定义了从一个XMPP 实体到另一个的视频传输过程。<br>l XEP-0181 Jingle DTMF（Dual Tone Multi-Frequency）。<br>l XEP-0183 Jingle Telepathy Transport Method。</p>
<p>5、 XMPP协议网络架构</p>
<p>XMPP是一个典型的C/S架构，而不是像大多数即时通讯软件一样，使用P2P客户端到客户端的架构，也就是说在大多数情况下，当两个客户端进行通讯时，他们的消息都是通过服务器传递的(也有例外，例如在两个客户端传输文件时)．采用这种架构，主要是为了简化客户端，将大多数工作放在服务器端进行，这样，客户端的工作就比较简单，而且，当增加功能时，多数是在服务器端进行．XMPP服务的框架结构如下图所示．XMPP中定义了三个角色，XMPP客户端，XMPP服务器、网关．通信能够在这三者的任意两个之间双向发生．服务器同时承担了客户端信息记录、连接管理和信息的路由功能．网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS(短信)、MSN、ICQ等．基本的网络形式是单客户端通过TCP／IP连接到单服务器，然后在之上传输XML，工作原理是：<br>(1) 点连接到服务器；<br>(2) 务器利用本地目录系统中的证书对其认证；<br>(3) 点指定目标地址，让服务器告知目标状态；<br>(4) 务器查找、连接并进行相互认证；<br>(5) 点之间进行交互；</p>
<p>6、 XMPP客户端<br>XMPP 系统的一个设计标准是必须支持简单的客户端。事实上，XMPP 系统架构对客户端只有很少的几个限制。一个XMPP 客户端必须支持的功能有：</p>
<ol>
<li>通过 TCP 套接字与XMPP 服务器进行通信；</li>
<li>解析组织好的 XML 信息包；</li>
<li>理解消息数据类型。</li>
</ol>
<p>XMPP 将复杂性从客户端转移到服务器端。这使得客户端编写变得非常容易，更新系统功能也同样变得容易。XMPP 客户端与服务端通过XML 在TCP 套接字的5222 端口进行通信，而不需要客户端之间直接进行通信。<br>基本的XMPP 客户端必须实现以下标准协议（XEP-0211）：<br>RFC3920 核心协议Core<br>RFC3921 即时消息和出席协议Instant Messaging and Presence<br>XEP-0030 服务发现Service Discovery<br>XEP-0115 实体能力Entity Capabilities</p>
<p>7、 XMPP服务器<br>XMPP 服务器遵循两个主要法则：<br>1、监听客户端连接，并直接与客户端应用程序通信；<br>2、与其他 XMPP 服务器通信；</p>
<p>XMPP开源服务器一般被设计成模块化，由各个不同的代码包构成，这些代码包分别处理Session管理、用户和服务器之间的通信、服务器之间的通信、DNS（Domain Name System）转换、存储用户的个人信息和朋友名单、保留用户在下线时收到的信息、用户注册、用户的身份和权限认证、根据用户的要求过滤信息和系统记录等。另外，服务器可以通过附加服务来进行扩展，如完整的安全策略，允许服务器组件的连接或客户端选择，通向其他消息系统的网关。<br>基本的XMPP 服务器必须实现以下标准协议<br>RFC3920 核心协议Core<br>RFC3921 即时消息和出席协议Instant Messaging and Presence<br>XEP-0030 服务发现Service Discovery</p>
<p>8、 XMPP网关</p>
<p>XMPP 突出的特点是可以和其他即时通信系统交换信息和用户在线状况。由于协议不同，XMPP 和其他系统交换信息必须通过协议的转换来实现，目前几种主流即时通信协议都没有公开，所以XMPP 服务器本身并没有实现和其他协议的转换，但它的架构允许转换的实现。实现这个特殊功能的服务端在XMPP 架构里叫做网关(gateway)。目前，XMPP 实现了和AIM、ICQ、IRC、MSN Massager、RSS0.9 和Yahoo Massager 的协议转换。由于网关的存在，XMPP 架构事实上兼容所有其他即时通信网络，这无疑大大提高了XMPP 的灵活性和可扩展性。</p>
<p>9、 XMPP地址格式</p>
<p>一个实体在XMPP网络结构中被称为一个接点，它有唯一的标示符jabber identifier(JID)，即实体地址，用来表示一个Jabber用户，但是也可以表示其他内容，例如一个聊天室．一个有效的JID包括一系列元素：<br>(1) 名(domain identifier)；<br>(2) 点(node identifier)；<br>(3) 源(resource identifier)．</p>
<p>它的格式是node@domain/resource，node@domain，类似电子邮件的地址格式．domain用来表示接点不同的设备或位置，这个是可选的，例如a在Server1上注册了一个用户，用户名为doom，那么a的JID就是doom@serverl，在发送消息时，指明doom@serverl就可以了，resource可以不用指定，但a在登录到这个Server时，fl的JID可能是doom@serverl、exodus(如果a用Exodus软件登录)，也可能是[email=doom@serverl/psi]doom@serverl/psi<a href="如果a用psi软件登录">/email</a>．资源只用来识别属于用户的位置或设备等，一个用户可以同时以多种资源与同一个XMPP服务器连接。</p>
<p>10、 XMPP消息格式</p>
<p>XMPP中定义了3个顶层XML元素: Message、Presence、IQ，下面针对这三种元素进行介绍。</p>
<p><message><br>用于在两个jabber用户之间发送信息。Jsm(jabber会话管理器)负责满足所有的消息，不管目标用户的状态如何。如果用户在线jsm立即提交;否则jsm就存储。<br>To : 标识消息的接收方。<br>from : 指发送方的名字或标示(id)<br>Text: 此元素包含了要提交给目标用户的信息。</message></p>
<p>结构如下所示:</p>
<p><message to="‘lily@jabber.org/contact’" type="’chat’"></message></p>
<p><body> 你好，在忙吗</body><br></p>
<p><presence><br>用来表明用户的状态，如：online、away、dnd(请勿打扰)等。当用户离线或改变自己的状态时，就会在stream的上下文中插入一个Presence元素，来表明自身的状态．结构如下所示：</presence></p>
<p><presence><br>From =‘lily @ jabber.com/contact’<br>To = ‘yaoman @ jabber.com/contact’</presence></p>
<p><status> Online </status><br></p>
<p><presence>元素可以取下面几种值:<br>Probe: 用于向接受消息方法发送特殊的请求<br>subscribe: 当接受方状态改变时，自动向发送方发送presence信息。<br>&lt; IQ &gt;</presence></p>
<p>一种请求／响应机制，从一个实体从发送请求，另外一个实体接受请求，并进行响应．例如，client在stream的上下文中插入一个元素，向Server请求得到自己的好友列表，Server返回一个，里面是请求的结果．</p>
<p><iq> 主要的属性是type。包括:<br>Get :获取当前域值。<br>Set :设置或替换get查询的值。<br>Result :说明成功的响应了先前的查询。<br>Error: 查询和响应中出现的错误。</iq></p>
<p>结构如下所示:</p>
<p><iq from="‘lily" @="" jabber.com="" contact’id="’1364564666’" type="’result’"><br>XMPP通信协议</iq></p>
<p>一、 Stream<br><!-- #################### 通信内容采用压缩技术，以及通信的相关协议 ####################### --></p>
<p><stream:stream xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client" from="127.0.0.1" id="e38900bc" xml:lang="en" version="1.0"><br><!--
 xmlns 表示通信客户端
 from 客户端的地址（来源）
 id
 lang 通信语言
 -->        </stream:stream></p>
<p><stream:features><br><!-- 开始tls协议[TLS]的频道加密方法 --></stream:features></p>
<p><starttls xmlns="urn:ietf:params:xml:ns:xmpp-tls"></starttls><br><!-- 加密技术、安全证书 --></p>
<p><mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"></mechanisms></p>
<p><mechanism>DIGEST-MD5</mechanism></p>
<p><mechanism>PLAIN</mechanism></p>
<p><mechanism>ANONYMOUS</mechanism></p>
<p><mechanism>CRAM-MD5</mechanism><br><br><!-- 采用压缩技术 --></p>
<p><compression xmlns="http://jabber.org/features/compress"></compression></p>
<p><method>zlib</method><br><br><!-- 权限 --></p>
<p><auth xmlns="http://jabber.org/features/iq-auth"><br><!-- 注册 --></auth></p>
<p><register xmlns="http://jabber.org/features/iq-register"><br></register></p>
<p>关于TSL 参考：<a href="http://www.jabbercn.org/RFC3920" target="_blank" rel="external">http://www.jabbercn.org/RFC3920</a><br>1、TSL协议遵循以下规则：<br>A、 一个遵守本协议的初始化实体必须（MUST）在初始化流的头信息中包含一个’version’属性并把值设为“1.0”。<br>B、 如果TLS握手发生在两个服务器之间，除非服务器声称的DNS主机名已经被解析，通信不能（MUST NOT）继续进行。<br>C、 当一个遵守本协议的接收实体接收了一个初始化流（它的头信息中包含一个’version’属性并且值设为“1.0”），在发送应答流的的头信息（其中包含版本标记）之后，它必须发送（MUST）<starttls>元素（名字空间为 ‘urn:ietf:params:xml:ns:xmpp-tls’）以及其他它支持的流特性。<br>D、 如果初始化实体选择使用TLS,TLS握手必须在SASL握手之前完成；这个顺序用于帮助保护SASL握手时发送的认证信息的安全，同时可以在必要的时候在TLS握手之前为SASL外部机制提供证书。<br>E、 TLS握手期间,一个实体不能（MUST NOT）在流的根元素中发送任何空格符号作为元素的分隔符（在下面的TLS示例中的任何空格符都仅仅是为了便于阅读）；这个禁令用来帮助确保安全层字节精度。<br>F、 接收实体必须（MUST）在发送<proceed> 元素的关闭符号”&gt;” 之后立刻开始TLS协商。初始化实体必须（MUST）在从接收实体接收到<proceed> 元素的关闭符号”&gt;” 之后立刻开始TLS协商。<br>G、 初始化实体必须（MUST）验证接收实体出示的证书；关于证书验证流程参见Certificate Validation ( 第十四章第二节)。<br>H、 证书必须（MUST）检查初始化实体(比如一个用户)提供的主机名；而不是通过DNS系统解析出来的主机名；例如，如果用户指定一个主机名”example.com”而一个DNS SRV [SRV]查询返回”im.example.com”，证书必须（MUST）检查”example.com”.如果任何种类的XMPP实体（例如客户端或服务器）的JID出现在一个证书里，它必须（MUST）表现为一个别名实体里面的UTF8字符串，存在于subjectAltName之中。如何使用 [ASN.1] 对象标识符 “id-on-xmppAddr” 定义在本文的第五章第一节第一小节。<br>I、 如果 TLS 握手成功了，接收实体必须（MUST） 丢弃TLS 生效之前从初始化实体得到的任何不可靠的信息<br>J、 如果 TLS 握手成功了，初始化实体必须（MUST） 丢弃TLS 生效之前从接收实体得到的任何不可靠的信息<br>K、 如果 TLS 握手成功了，接收实体不能(MUST NOT)在流重新开始的时候通过提供其他的流特性来向初始化实体提供 STARTTLS 扩展<br>L、 如果 TLS 握手成功了，初始化实体必须(MUST)继续进行SASL握手<br>M、 如果 TLS 握手失败了，接收实体必须（MUST）终止XML流和相应的TCP连接。<br>N、 关于必须（MUST）支持的机制，参照 Mandatory-to-Implement Technologies (第十四章第七节) 。<br>2、当一个初始化实体用TLS保护一个和接收实体之间的流，其步骤如下:<br>A. 初始化实体打开一个TCP连接，发送一个打开的XML流头信息（其’version’属性设置为”1.0”）给接收实体以初始化一个流。<br>B. 接收实体打开一个TCP连接，发送一个XML流头信息（其’version’属性设置为”1.0”）给初始化实体作为应答。<br>C. 接收实体向初始化实体提议STARTTLS范围（包括其他支持的流特性），如果TLS对于和接收实体交互是必需的，它应该（SHOULD）在<starttls>元素中包含子元素<required><br>D. 初始化实体发出STARTTLS命令(例如, 一个符合’urn:ietf:params:xml:ns:xmpp-tls’名字空间的 <starttls> 元素) 以通知接收实体它希望开始一个TLS握手来保护流。<br>E. 接收实体必须（MUST）以’urn:ietf:params:xml:ns:xmpp-tls’名字空间中的<proceed>元素或<failure>元素应答。如果失败，接收实体必须（MUST）终止XML流和相应的TCP连接。如果继续进行，接收实体必须（MUST）尝试通过TCP连接完成TLS握手并且在TLS握手完成之前不能（MUST NOT）发送任何其他XML数据。<br>F. 初始化实体和接收实体尝试完成TLS握手。（要符合[TLS]规范）<br>G. 如果 TLS 握手不成功, 接收实体必须（MUST）终止 TCP 连接. 如果 TLS 握手成功, 初始化实体必须（MUST）发送给接收实体一个打开的XML流头信息来初始化一个新的流（先发送一个关闭标签是不必要的,因为接收实体和初始化实体必须(MUST)确保原来的流在TLS握手成功之后被关闭） 。<br>H. 在从初始化实体收到新的流头信息之后，接收实体必须（MUST）发送一个新的XML流头信息给初始化实体作为应答，其中应包含可用的特性但不包含STATRTTLS特性。</failure></proceed></starttls></required></starttls></proceed></proceed></starttls></p>
<p><a href="http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html</a></p>
<p>在文章开始，请你了解和熟悉openfire方面的相关知识，这样对你理解下面代码以及下面代码的用途有很好的了解。同时，你可能需要安装一个简单的CS聊天工具，来测试你的代码是否成功的在openfire服务器上建立会话链接，并成功的向在线用户发送聊天消息。<br>必须了解：<a href="http://www.cnblogs.com/hoojo/archive/2012/05/17/2506769.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/05/17/2506769.html</a><br><a href="http://www.cnblogs.com/hoojo/archive/2012/05/13/2498151.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/05/13/2498151.html</a> （非windows 系统）<br>可选：<a href="http://www.cnblogs.com/hoojo/archive/2012/05/17/2506845.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/05/17/2506845.html</a><br><a href="http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html</a></p>
<p>聊天软件Spark，用于测试聊天消息发送是否成功，下载地址：<a href="http://www.igniterealtime.org/do" target="_blank" rel="external">http://www.igniterealtime.org/do</a> … ark/spark_2_6_3.exe</p>
<p>然后你需要添加smack相关的jar包<br>smack.jar<br>smackx.jar<br>jar包下载地址：<a href="http://www.igniterealtime.org/do" target="_blank" rel="external">http://www.igniterealtime.org/do</a> … ack/smack_3_2_2.zip<br>代码中还用到了junit，junit jar下载地址：<a href="http://ebr.springsource.com/repo" target="_blank" rel="external">http://ebr.springsource.com/repo</a> … 8.2&amp;type=binary</p>
<p>下面开始代码部分<br>package com.hoo.smack;</p>
<p>import java.util.Collection;<br>import java.util.Iterator;<br>import javax.net.SocketFactory;<br>import org.jivesoftware.smack.AccountManager;<br>import org.jivesoftware.smack.Chat;<br>import org.jivesoftware.smack.ChatManager;<br>import org.jivesoftware.smack.Connection;<br>import org.jivesoftware.smack.ConnectionConfiguration;<br>import org.jivesoftware.smack.MessageListener;<br>import org.jivesoftware.smack.Roster;<br>import org.jivesoftware.smack.RosterEntry;<br>import org.jivesoftware.smack.XMPPConnection;<br>import org.jivesoftware.smack.XMPPException;<br>import org.jivesoftware.smack.packet.Message;<br>import org.jivesoftware.smack.packet.Presence;<br>import org.jivesoftware.smack.packet.Session;<br>import org.jivesoftware.smack.packet.Message.Type;<br>import org.junit.After;<br>import org.junit.Before;<br>import org.junit.Test;</p>
<p>/**</p>
<ul>
<li><b>function:</b> 利用Smack框架完成 XMPP 协议通信</li>
<li>@author hoojo</li>
<li>@createDate 2012-5-22 上午10:28:18</li>
<li>@file ConnectionServerTest.java</li>
<li>@package com.hoo.smack.conn</li>
<li>@project jwchat</li>
<li>@blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank" rel="external">http://blog.csdn.net/IBM_hoojo</a></li>
<li>@email hoojo_@126.com</li>
<li>@version 1.0<br>*/<br>public class SmackXMPPTest {</li>
</ul>
<p>private Connection connection;<br>private ConnectionConfiguration config;<br>/<em>* openfire服务器address </em>/<br>private final static String server = “192.168.8.32”;</p>
<p>private final void fail(Object o) {<br>if (o != null) {<br>System.out.println(o);<br>}<br>}</p>
<p>private final void fail(Object o, Object… args) {<br>if (o != null &amp;&amp; args != null &amp;&amp; args.length &gt; 0) {<br>String s = o.toString();<br>for (int i = 0; i &lt; args.length; i++) {<br>String item = args == null ? “” : args.toString();<br>if (s.contains(“{“ + i + “}”)) {<br>s = s.replace(“{“ + i + “}”, item);<br>} else {<br>s += “ “ + item;<br>}<br>}<br>System.out.println(s);<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> 初始Smack对openfire服务器链接的基本配置</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:06:42<br><em>/<br>@Before<br>public void init() {<br>try {<br>//connection = new XMPPConnection(server);<br>//connection.connect();<br>/** 5222是openfire服务器默认的通信端口，你可以登录<a href="http://192.168.8.32:9090/到管理员控制台查看客户端到服务器端口" target="_blank" rel="external">http://192.168.8.32:9090/到管理员控制台查看客户端到服务器端口</a> </em>/<br>config = new ConnectionConfiguration(server, 5222);</li>
</ul>
<p>/<strong> 是否启用压缩 */<br>config.setCompressionEnabled(true);<br>/</strong> 是否启用安全验证 <em>/<br>config.setSASLAuthenticationEnabled(true);<br>/** 是否启用调试 </em>/<br>config.setDebuggerEnabled(false);<br>//config.setReconnectionAllowed(true);<br>//config.setRosterLoadedAtLogin(true);</p>
<p>/<strong> 创建connection链接 */<br>connection = new XMPPConnection(config);<br>/</strong> 建立连接 */<br>connection.connect();<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>fail(connection);<br>fail(connection.getConnectionID());<br>}</p>
<p>@After<br>public void destory() {<br>if (connection != null) {<br>connection.disconnect();<br>connection = null;<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> ConnectionConfiguration 的基本配置相关信息</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:11:25<br>*/<br>@Test<br>public void testConfig() {<br>fail(“PKCS11Library: “ + config.getPKCS11Library());<br>fail(“ServiceName: {0}”, config.getServiceName());<br>// ssl证书密码<br>fail(“TruststorePassword: {0}”, config.getTruststorePassword());<br>fail(“TruststorePath: {0}”, config.getTruststorePath());<br>fail(“TruststoreType: {0}”, config.getTruststoreType());</li>
</ul>
<p>SocketFactory socketFactory = config.getSocketFactory();<br>fail(“SocketFactory: {0}”, socketFactory);<br>/<em>try {<br>fail(“createSocket: {0}”, socketFactory.createSocket(“localhost”, 3333));<br>} catch (IOException e) {<br>e.printStackTrace();<br>}</em>/<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> Connection 基本方法信息</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:12:04<br><em>/<br>@Test<br>public void testConnection() {<br>/** 用户管理 </em>/<br>AccountManager accountManager = connection.getAccountManager();<br>for (String attr : accountManager.getAccountAttributes()) {<br>fail(“AccountAttribute: {0}”, attr);<br>}<br>fail(“AccountInstructions: {0}”, accountManager.getAccountInstructions());<br>/<strong> 是否链接 */<br>fail(“isConnected:”, connection.isConnected());<br>fail(“isAnonymous:”, connection.isAnonymous());<br>/</strong> 是否有权限 <em>/<br>fail(“isAuthenticated:”, connection.isAuthenticated());<br>fail(“isSecureConnection:”, connection.isSecureConnection());<br>/** 是否使用压缩 </em>/<br>fail(“isUsingCompression:”, connection.isUsingCompression());<br>}</li>
</ul>
<p>/**</p>
<ul>
<li><b>function:</b> 用户管理器</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:22:31<br>*/<br>@Test<br>public void testAccountManager() {<br>AccountManager accountManager = connection.getAccountManager();<br>for (String attr : accountManager.getAccountAttributes()) {<br>fail(“AccountAttribute: {0}”, attr);<br>}<br>fail(“AccountInstructions: {0}”, accountManager.getAccountInstructions());</li>
</ul>
<p>fail(“supportsAccountCreation: {0}”, accountManager.supportsAccountCreation());<br>try {<br>/<strong> 创建一个用户boy，密码为boy；你可以在管理员控制台页面<a href="http://192.168.8.32:9090/user-summary.jsp查看用户/组的相关信息，来查看是否成功创建用户" target="_blank" rel="external">http://192.168.8.32:9090/user-summary.jsp查看用户/组的相关信息，来查看是否成功创建用户</a> */<br>accountManager.createAccount(“boy”, “boy”);<br>/</strong> 修改密码 */<br>accountManager.changePassword(“abc”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>}</p>
<p>@Test<br>public void testUser() {<br>try {<br>/<strong> 用户登陆，用户名、密码 */<br>connection.login(“hoojo”, “hoojo”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>/</strong> 获取当前登陆用户 */<br>fail(“User:”, connection.getUser());</p>
<p>/<em>* 所有用户组 </em>/<br>Roster roster = connection.getRoster();</p>
<p>/<em>* 好友用户组，你可以用Spark添加用户好友，这样这里就可以查询到相关的数据 </em>/<br>Collection<rosterentry> rosterEntiry = roster.getEntries();<br>Iterator<rosterentry> iter = rosterEntiry.iterator();<br>while (iter.hasNext()) {<br>RosterEntry entry = iter.next();<br>fail(“Groups: {0}, Name: {1}, Status: {2}, Type: {3}, User: {4}”, entry.getGroups(), entry.getName(), entry.getStatus(), entry.getType(), entry);<br>}</rosterentry></rosterentry></p>
<p>fail(“——————————-“);<br>/<em>* 未处理、验证好友，添加过的好友，没有得到对方同意 </em>/<br>Collection<rosterentry> unfiledEntries = roster.getUnfiledEntries();<br>iter = unfiledEntries.iterator();<br>while (iter.hasNext()) {<br>RosterEntry entry = iter.next();<br>fail(“Groups: {0}, Name: {1}, Status: {2}, Type: {3}, User: {4}”, entry.getGroups(), entry.getName(), entry.getStatus(), entry.getType(), entry);<br>}<br>}</rosterentry></p>
<p>@Test<br>@SuppressWarnings(“static-access”)<br>public void testPacket() {<br>try {<br>connection.login(“hoojo”, “hoojo”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}</p>
<p>//Packet packet = new Data(new DataPacketExtension(“jojo@” + server, 2, “this is a message”));<br>//connection.sendPacket(packet);</p>
<p>/<em>* 更改用户状态，available=true表示在线，false表示离线，status状态签名；当你登陆后，在Spark客户端软件中就可以看到你登陆的状态 </em>/<br>Presence presence = new Presence(Presence.Type.available);<br>presence.setStatus(“Q我吧”);<br>connection.sendPacket(presence);</p>
<p>Session session = new Session();<br>String sessid = session.nextID();<br>connection.sendPacket(session);<br>/** 向jojo@192.168.8.32 发送聊天消息，此时你需要用Spark软件登陆jojo这个用户，</p>
<ul>
<li>这样代码就可以向jojo这个用户发送聊天消息，Spark登陆的jojo用户就可以接收到消息<br><strong>/<br>/</strong> Type.chat 表示聊天，groupchat多人聊天，error错误，headline在线用户； */<br>Message message = new Message(“jojo@” + server, Type.chat);<br>//Message message = new Message(sessid, Type.chat);<br>message.setBody(“h!~ jojo, I’am is hoojo!”);<br>connection.sendPacket(message);</li>
</ul>
<p>try {<br>Thread.sleep(1);<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> 测试聊天消息管理类</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午05:03:23<br><em>/<br>@Test<br>public void testChatManager() {<br>/** 设置状态 </em>/<br>try {<br>connection.login(“hoojo”, “hoojo”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}</li>
</ul>
<p>/<em>* 设置状态 </em>/<br>Presence presence = new Presence(Presence.Type.available);<br>presence.setStatus(“Q我吧”);<br>connection.sendPacket(presence);</p>
<p>/<strong> 获取当前登陆用户的聊天管理器 */<br>ChatManager chatManager = connection.getChatManager();<br>/</strong> 为指定用户创建一个chat，MyMessageListeners用于监听对方发过来的消息  <em>/<br>Chat chat = chatManager.createChat(“jojo@” + server, new MyMessageListeners());<br>try {<br>/** 发送消息 </em>/<br>chat.sendMessage(“h!~ jojo……”);</p>
<p>/<em>* 用message对象发送消息 </em>/<br>Message message = new Message();<br>message.setBody(“message”);<br>message.setProperty(“color”, “red”);<br>chat.sendMessage(message);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>try {<br>Thread.sleep(1000 * 1000);<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> 消息监听器，用户监听对方发送的消息，也可以想对方发送消息</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午05:05:31</li>
<li>@file SmackXMPPTest.java</li>
<li>@package com.hoo.smack</li>
<li>@project jwchat</li>
<li>@blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank" rel="external">http://blog.csdn.net/IBM_hoojo</a></li>
<li>@email hoojo_@126.com</li>
<li>@version 1.0<br><em>/<br>class MyMessageListeners implements MessageListener {<br>public void processMessage(Chat chat, Message message) {<br>try {<br>/** 发送消息 </em>/<br>chat.sendMessage(“dingding……” + message.getBody());<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>/<em>* 接收消息 </em>/<br>fail(“From: {0}, To: {1}, Type: {2}, Sub: {3}”, message.getFrom(), message.getTo(), message.getType(), message.toXML());<br>/<em>Collection<body> bodys =  message.getBodies();<br>for (Body body : bodys) {<br>fail(“bodies[{0}]”, body.getMessage());<br>}<br>//fail(message.getLanguage());<br>//fail(message.getThread());<br>//fail(message.getXmlns());</body></em>/<br>fail(“body: “, message.getBody());<br>}<br>}<br>}<br>好了，这些都是smack的基本功能，还有更多的东西需要研究，下次有机会再分享！</li>
</ul>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2016/02/13/ios-xmpp协议/">
    <time datetime="2016-02-12T17:29:11.000Z" class="entry-date">
        2016-02-13
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
</article>






  
    <article id="post-ios-加密方式" class="post-ios-加密方式 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/11/17/ios-加密方式/">ios-加密方式</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/11/17/ios-加密方式/" data-id="ciq0acdud00018as68q4ayxrm" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>iOS代码加密常用加密方式，常见的iOS代码加密常用加密方式算法包括MD5加密、AES加密、BASE64加密，三大算法iOS代码加密是如何进行加密的，且看下文</p>
<p>MD5 iOS代码加密<br>创建MD5类，代码如下</p>
<p>#import <foundation foundation.h=""><br>@interface CJMD5 : NSObject<br>+(NSString <em>)md5HexDigest:(NSString </em>)input;<br>@end</foundation></p>
<p>#import “CJMD5.h”</p>
<p>#import <commoncrypto commondigest.h=""><br>@implementation CJMD5<br>+(NSString <em>)md5HexDigest:(NSString </em>)input{</commoncrypto></p>
<p>const char<em> str = [input UTF8String];<br>unsigned char result[CC_MD5_DIGEST_LENGTH];<br>CC_MD5(str, strlen(str), result);<br>NSMutableString </em>ret = [NSMutableString stringWithCapacity:CC_MD5_DIGEST_LENGTH];</p>
<p>for(int i = 0; i&lt;CC_MD5_DIGEST_LENGTH; i++) {<br>[ret appendFormat:@”%02X”,result];<br>}<br>return ret;<br>}<br>@end<br>3<br>MD5是不可逆的只有加密没有解密，iOS代码加密使用方式如下<br>NSString <em>userName = @”cerastes”;<br>NSString </em>password = @”hello Word”;<br>//   MD5加密<br>NSString <em>md5 = [CJMD5 md5HexDigest:password];<br>NSLog(@”%@”,md5);<br>END<br>AES加密iOS代码加密<br>1<br>AES加密iOS代码加密使用方法<br>//  AES加密<br>NSString </em>encryptedData = [AESCrypt encrypt:userName password:password];//加密<br>NSString *message = [AESCrypt decrypt:encryptedData password:password]; //解密<br>NSLog(@”加密结果 = %@”,encryptedData);<br>NSLog(@”解密结果 = %@”,message);<br>END<br>BASE64加密iOS代码加密<br>1<br>BASE64加密iOS代码加密添加如下方法<br>.h</p>
<ul>
<li>(NSString<em>)encodeBase64String:(NSString </em>)input;</li>
<li>(NSString<em>)decodeBase64String:(NSString </em>)input;</li>
<li>(NSString<em>)encodeBase64Data:(NSData </em>)data;</li>
<li>(NSString<em>)decodeBase64Data:(NSData </em>)data;<br>2<br>.m</li>
<li>(NSString<em>)encodeBase64String:(NSString </em> )input {<br>NSData <em>data = [input dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];<br>data = [GTMBase64 encodeData:data];<br>NSString </em>base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>return base64String;<br>}</li>
<li>(NSString<em>)decodeBase64String:(NSString </em> )input {<br>NSData <em>data = [input dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:YES];<br>data = [GTMBase64 decodeData:data];<br>NSString </em>base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>return base64String;<br>}</li>
<li>(NSString<em>)encodeBase64Data:(NSData </em>)data {<br>data = [GTMBase64 encodeData:data];<br>NSString *base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>return base64String;<br>}</li>
<li>(NSString<em>)decodeBase64Data:(NSData </em>)data {<br>data = [GTMBase64 decodeData:data];<br>NSString <em>base64String = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];<br>return base64String;<br>}<br>3<br>BASE64加密iOS代码加密使用方法<br>//    BASE64加密<br>NSString </em>baseEncodeString = [GTMBase64 encodeBase64String:password];<br>NSString *baseDecodeString = [GTMBase64 decodeBase64String:baseEncodeString];<br>NSLog(@”baseEncodeString = %@”,baseEncodeString);<br>NSLog(@”baseDecodeString = %@”,baseDecodeString);<br>END<br>iOS应用代码加密<br>1<br>除了以上的三种算法的iOS代码加密之外，iOS应用代码加密也是非常重要的，这里就不贴代码了，主要的iOS代码加密方式如下，iOS应用代码加密是 爱 加 密 平台提供的专业的iOS加密服务。<br>iOS代码加密常用加密方式<br>2<br>1）本地数据加密<br>对NSUserDefaults，sqlite存储文件数据加密，保护帐号和关键信息。<br>2）URL编码加密<br>对程序中出现的URL进行编码加密，防止URL被静态分析<br>3）网络传输数据加密<br>对客户端传输数据提供加密方案，有效防止通过网络接口的拦截获取<br>4）方法体，方法名高级混淆<br>对应用程序的方法名和方法体进行混淆，保证源码被逆向后无法解析代码<br>5）程序结构混排加密<br>对应用程序逻辑结构进行打乱混排，保证源码可读性降到最低</li>
</ul>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/11/17/ios-加密方式/">
    <time datetime="2015-11-17T04:47:35.000Z" class="entry-date">
        2015-11-17
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
</article>






  
    <article id="post-ios-Runtime机制" class="post-ios-Runtime机制 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/06/23/ios-Runtime机制/">ios-Runtime机制</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/06/23/ios-Runtime机制/" data-id="ciq0acduk00038as6vkz5sdfj" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>Objective-C语言是一门动态语言，它将很多静态语言在编译和链接时期做的事放到了运行时来处理。这种动态语言的优势在于：我们写代码时更具灵活性，如我们可以把消息转发给我们想要的对象，或者随意交换一个方法的实现等。</p>
<p>这种特性意味着Objective-C不仅需要一个编译器，还需要一个运行时系统来执行编译的代码。对于Objective-C来说，这个运行时系统就像一个操作系统一样：它让所有的工作可以正常的运行。这个运行时系统即Objc Runtime。Objc Runtime其实是一个Runtime库，它基本上是用C和汇编写的，这个库使得C语言有了面向对象的能力。</p>
<p>Runtime库主要做下面几件事：</p>
<p>封装：在这个库中，对象可以用C语言中的结构体表示，而方法可以用C函数来实现，另外再加上了一些额外的特性。这些结构体和函数被runtime函数封装后，我们就可以在程序运行时创建，检查，修改类、对象和它们的方法了。<br>找出方法的最终执行代码：当程序执行[object doSomething]时，会向消息接收者(object)发送一条消息(doSomething)，runtime会根据消息接收者是否能响应该消息而做出不同的反应。这将在后面详细介绍。<br>Objective-C runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有 iOS Apps，Legacy Runtime 是早期用来给32位 Mac OS X Apps 用的，也就是可以不用管就是了。</p>
<p>在这一系列文章中，我们将介绍runtime的基本工作原理，以及如何利用它让我们的程序变得更加灵活。在本文中，我们先来介绍一下类与对象，这是面向对象的基础，我们看看在Runtime中，类是如何实现的。</p>
<p>类与对象基础数据结构</p>
<p>Class</p>
<p>Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。它的定义如下：</p>
<p>typedef struct objc_class *Class;<br>查看objc/runtime.h中objc_class结构体的定义如下：</p>
<p>struct objc_class {</p>
<p>Class isa  OBJC_ISA_AVAILABILITY;</p>
<p>#if !<strong>OBJC2</strong></p>
<p>Class super_class                       OBJC2_UNAVAILABLE;  // 父类</p>
<p>const char *name                        OBJC2_UNAVAILABLE;  // 类名</p>
<p>long version                            OBJC2_UNAVAILABLE;  // 类的版本信息，默认为0</p>
<p>long info                               OBJC2_UNAVAILABLE;  // 类信息，供运行期使用的一些位标识</p>
<p>long instance_size                      OBJC2_UNAVAILABLE;  // 该类的实例变量大小</p>
<p>struct objc_ivar_list *ivars            OBJC2_UNAVAILABLE;  // 该类的成员变量链表</p>
<p>struct objc_method_list **methodLists   OBJC2_UNAVAILABLE;  // 方法定义的链表</p>
<p>struct objc_cache *cache                OBJC2_UNAVAILABLE;  // 方法缓存</p>
<p>struct objc_protocol_list *protocols    OBJC2_UNAVAILABLE;  // 协议链表</p>
<p>#endif</p>
<p>} OBJC2_UNAVAILABLE;<br>在这个定义中，下面几个字段是我们感兴趣的</p>
<p>isa：需要注意的是在Objective-C中，所有的类自身也是一个对象，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)，我们会在后面介绍它。<br>super_class：指向该类的父类，如果该类已经是最顶层的根类(如NSObject或NSProxy)，则super_class为NULL。<br>cache：用于缓存最近使用的方法。一个接收者对象接收到一个消息时，它会根据isa指针去查找能够响应这个消息的对象。在实际使用中，这个对象只有一部分方法是常用的，很多方法其实很少用或者根本用不上。这种情况下，如果每次消息来时，我们都是methodLists中遍历一遍，性能势必很差。这时，cache就派上用场了。在我们每次调用过一个方法后，这个方法就会被缓存到cache列表中，下次调用的时候runtime就会优先去cache中查找，如果cache没有，才去methodLists中查找方法。这样，对于那些经常用到的方法的调用，但提高了调用的效率。<br>version：我们可以使用这个字段来提供类的版本信息。这对于对象的序列化非常有用，它可是让我们识别出不同类定义版本中实例变量布局的改变。<br>针对cache，我们用下面例子来说明其执行过程：</p>
<p>NSArray *array = [[NSArray alloc] init];<br>其流程是：</p>
<p>[NSArray alloc]先被执行。因为NSArray没有+alloc方法，于是去父类NSObject去查找。<br>检测NSObject是否响应+alloc方法，发现响应，于是检测NSArray类，并根据其所需的内存空间大小开始分配内存空间，然后把isa指针指向NSArray类。同时，+alloc也被加进cache列表里面。<br>接着，执行-init方法，如果NSArray响应该方法，则直接将其加入cache；如果不响应，则去父类查找。<br>在后期的操作中，如果再以[[NSArray alloc] init]这种方式来创建数组，则会直接从cache中取出相应的方法，直接调用。<br>objc_object与id</p>
<p>objc_object是表示一个类的实例的结构体，它的定义如下(objc/objc.h)：</p>
<p>struct objc_object {</p>
<p>Class isa  OBJC_ISA_AVAILABILITY;</p>
<p>};</p>
<p>typedef struct objc_object *id;<br>可以看到，这个结构体只有一个字体，即指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法。找到后即运行这个方法。</p>
<p>当创建一个特定类的实例对象时，分配的内存包含一个objc_object数据结构，然后是类的实例变量的数据。NSObject类的alloc和allocWithZone:方法使用函数class_createInstance来创建objc_object数据结构。</p>
<p>另外还有我们常见的id，它是一个objc_object结构类型的指针。它的存在可以让我们实现类似于C++中泛型的一些操作。该类型的对象可以转换为任何一种对象，有点类似于C语言中void *指针类型的作用。</p>
<p>objc_cache</p>
<p>上面提到了objc_class结构体中的cache字段，它用于缓存调用过的方法。这个字段是一个指向objc_cache结构体的指针，其定义如下：</p>
<p>struct objc_cache {</p>
<p>unsigned int mask /<em> total = mask + 1 </em>/                 OBJC2_UNAVAILABLE;</p>
<p>unsigned int occupied                                    OBJC2_UNAVAILABLE;</p>
<p>Method buckets[1]                                        OBJC2_UNAVAILABLE;</p>
<p>};<br>该结构体的字段描述如下：</p>
<p>mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。<br>occupied：一个整数，指定实际占用的缓存bucket的总数。<br>buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。<br>元类(Meta Class)</p>
<p>在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。如：</p>
<p>NSArray *array = [NSArray array];<br>这个例子中，+array消息发送给了NSArray类，而这个NSArray也是一个对象。既然是对象，那么它也是一个objc_object指针，它包含一个指向其类的一个isa指针。那么这些就有一个问题了，这个isa指针指向什么呢？为了调用+array方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念</p>
<p>meta-class是一个类对象的类。<br>当我们向一个对象发送消息时，runtime会在这个对象所属的这个类的方法列表中查找方法；而向一个类发送消息时，会在这个类的meta-class的方法列表中查找。</p>
<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有一个单独的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<p>再深入一下，meta-class也是一个类，也可以向它发送一个消息，那么它的isa又是指向什么呢？为了不让这种结构无限延伸下去，Objective-C的设计者让所有的meta-class的isa指向基类的meta-class，以此作为它们的所属类。即，任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。</p>
<p>通过上面的描述，再加上对objc_class结构体中super_class指针的分析，我们就可以描绘出类及相应meta-class类的一个继承体系了，如下图所示：</p>
<p>image</p>
<p>对于NSObject继承体系来说，其实例方法对体系中的所有实例、类和meta-class都是有效的；而类方法对于体系内的所有类和meta-class都是有效的。</p>
<p>讲了这么多，我们还是来写个例子吧：</p>
<p>void TestMetaClass(id self, SEL _cmd) {</p>
<p>NSLog(@”This objcet is %p”, self);</p>
<p>NSLog(@”Class is %@, super class is %@”, [self class], [self superclass]);</p>
<p>Class currentClass = [self class];</p>
<p>for (int i = 0; i &lt; 4; i++) {</p>
<p>NSLog(@”Following the isa pointer %d times gives %p”, i, currentClass);</p>
<p>currentClass = objc_getClass((__bridge void *)currentClass);</p>
<p>}</p>
<p>NSLog(@”NSObject’s class is %p”, [NSObject class]);</p>
<p>NSLog(@”NSObject’s meta class is %p”, objc_getClass((__bridge void *)[NSObject class]));</p>
<p>}</p>
<p>#pragma mark -</p>
<p>@implementation Test</p>
<ul>
<li>(void)ex_registerClassPair {</li>
</ul>
<p>Class newClass = objc_allocateClassPair([NSError class], “TestClass”, 0);</p>
<p>class_addMethod(newClass, @selector(testMetaClass), (IMP)TestMetaClass, “v@:”);</p>
<p>objc_registerClassPair(newClass);</p>
<p>id instance = [[newClass alloc] initWithDomain:@”some domain” code:0 userInfo:nil];</p>
<p>[instance performSelector:@selector(testMetaClass)];</p>
<p>}</p>
<p>@end<br>这个例子是在运行时创建了一个NSError的子类TestClass，然后为这个子类添加一个方法testMetaClass，这个方法的实现是TestMetaClass函数。</p>
<p>运行后，打印结果是</p>
<p>2014-10-20 22:57:07.352 mountain[1303:41490] This objcet is 0x7a6e22b0</p>
<p>2014-10-20 22:57:07.353 mountain[1303:41490] Class is TestStringClass, super class is NSError</p>
<p>2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 0 times gives 0x7a6e21b0</p>
<p>2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 1 times gives 0x0</p>
<p>2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 2 times gives 0x0</p>
<p>2014-10-20 22:57:07.353 mountain[1303:41490] Following the isa pointer 3 times gives 0x0</p>
<p>2014-10-20 22:57:07.353 mountain[1303:41490] NSObject’s class is 0xe10000</p>
<p>2014-10-20 22:57:07.354 mountain[1303:41490] NSObject’s meta class is 0x0<br>我们在for循环中，我们通过objc_getClass来获取对象的isa，并将其打印出来，依此一直回溯到NSObject的meta-class。分析打印结果，可以看到最后指针指向的地址是0x0，即NSObject的meta-class的类地址。</p>
<p>这里需要注意的是：我们在一个类对象调用class方法是无法获取meta-class，它只是返回类而已。</p>
<p>类与对象操作函数</p>
<p>runtime提供了大量的函数来操作类与对象。类的操作方法大部分是以class为前缀的，而对象的操作方法大部分是以objc或object_为前缀。下面我们将根据这些方法的用途来分类讨论这些方法的使用。</p>
<p>类相关操作函数</p>
<p>我们可以回过头去看看objc_class的定义，runtime提供的操作类的方法主要就是针对这个结构体中的各个字段的。下面我们分别介绍这一些的函数。并在最后以实例来演示这些函数的具体用法。</p>
<p>类名(name)</p>
<p>类名操作的函数主要有：</p>
<p>// 获取类的类名</p>
<p>const char * class_getName ( Class cls );<br>● 对于class_getName函数，如果传入的cls为Nil，则返回一个字字符串。</p>
<p>父类(super_class)和元类(meta-class)</p>
<p>父类和元类操作的函数主要有：</p>
<p>// 获取类的父类</p>
<p>Class class_getSuperclass ( Class cls );</p>
<p>// 判断给定的Class是否是一个元类</p>
<p>BOOL class_isMetaClass ( Class cls );<br>● class_getSuperclass函数，当cls为Nil或者cls为根类时，返回Nil。不过通常我们可以使用NSObject类的superclass方法来达到同样的目的。</p>
<p>● class_isMetaClass函数，如果是cls是元类，则返回YES；如果否或者传入的cls为Nil，则返回NO。</p>
<p>实例变量大小(instance_size)</p>
<p>实例变量大小操作的函数有：</p>
<p>// 获取实例大小</p>
<p>size_t class_getInstanceSize ( Class cls );<br>成员变量(ivars)及属性</p>
<p>在objc_class中，所有的成员变量、属性的信息是放在链表ivars中的。ivars是一个数组，数组中每个元素是指向Ivar(变量信息)的指针。runtime提供了丰富的函数来操作这一字段。大体上可以分为以下几类：</p>
<p>1.成员变量操作函数，主要包含以下函数：</p>
<p>// 获取类中指定名称实例成员变量的信息</p>
<p>Ivar class_getInstanceVariable ( Class cls, const char *name );</p>
<p>// 获取类成员变量的信息</p>
<p>Ivar class_getClassVariable ( Class cls, const char *name );</p>
<p>// 添加成员变量</p>
<p>BOOL class_addIvar ( Class cls, const char <em>name, size_t size, uint8_t alignment, const char </em>types );</p>
<p>// 获取整个成员变量列表</p>
<p>Ivar <em> class_copyIvarList ( Class cls, unsigned int </em>outCount );<br>● class_getInstanceVariable函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。</p>
<p>● class_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。</p>
<p>● Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。</p>
<p>● class_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。</p>
<p>2.属性操作函数，主要包含以下函数：</p>
<p>// 获取指定的属性</p>
<p>objc_property_t class_getProperty ( Class cls, const char *name );</p>
<p>// 获取属性列表</p>
<p>objc_property_t <em> class_copyPropertyList ( Class cls, unsigned int </em>outCount );</p>
<p>// 为类添加属性</p>
<p>BOOL class_addProperty ( Class cls, const char <em>name, const objc_property_attribute_t </em>attributes, unsigned int attributeCount );</p>
<p>// 替换类的属性</p>
<p>void class_replaceProperty ( Class cls, const char <em>name, const objc_property_attribute_t </em>attributes, unsigned int attributeCount );<br>这一种方法也是针对ivars来操作，不过只操作那些是属性的值。我们在后面介绍属性时会再遇到这些函数。</p>
<p>3.在MAC OS X系统中，我们可以使用垃圾回收器。runtime提供了几个函数来确定一个对象的内存区域是否可以被垃圾回收器扫描，以处理strong/weak引用。这几个函数定义如下：</p>
<p>const uint8_t * class_getIvarLayout ( Class cls );</p>
<p>void class_setIvarLayout ( Class cls, const uint8_t *layout );</p>
<p>const uint8_t * class_getWeakIvarLayout ( Class cls );</p>
<p>void class_setWeakIvarLayout ( Class cls, const uint8_t *layout );<br>但通常情况下，我们不需要去主动调用这些方法；在调用objc_registerClassPair时，会生成合理的布局。在此不详细介绍这些函数。</p>
<p>方法(methodLists)</p>
<p>方法操作主要有以下函数：</p>
<p>// 添加方法</p>
<p>BOOL class_addMethod ( Class cls, SEL name, IMP imp, const char *types );</p>
<p>// 获取实例方法</p>
<p>Method class_getInstanceMethod ( Class cls, SEL name );</p>
<p>// 获取类方法</p>
<p>Method class_getClassMethod ( Class cls, SEL name );</p>
<p>// 获取所有方法的数组</p>
<p>Method <em> class_copyMethodList ( Class cls, unsigned int </em>outCount );</p>
<p>// 替代方法的实现</p>
<p>IMP class_replaceMethod ( Class cls, SEL name, IMP imp, const char *types );</p>
<p>// 返回方法的具体实现</p>
<p>IMP class_getMethodImplementation ( Class cls, SEL name );</p>
<p>IMP class_getMethodImplementation_stret ( Class cls, SEL name );</p>
<p>// 类实例是否响应指定的selector</p>
<p>BOOL class_respondsToSelector ( Class cls, SEL sel );<br>● class_addMethod的实现会覆盖父类的方法实现，但不会取代本类中已存在的实现，如果本类中包含一个同名的实现，则函数会返回NO。如果要修改已存在实现，可以使用method_setImplementation。一个Objective-C方法是一个简单的C函数，它至少包含两个参数—self和_cmd。所以，我们的实现函数(IMP参数指向的函数)至少需要两个参数，如下所示：</p>
<p>void myMethodIMP(id self, SEL _cmd)</p>
<p>{</p>
<p>// implementation ….</p>
<p>}<br>与成员变量不同的是，我们可以为类动态添加方法，不管这个类是否已存在。</p>
<p>另外，参数types是一个描述传递给方法的参数类型的字符数组，这就涉及到类型编码，我们将在后面介绍。</p>
<p>● class_getInstanceMethod、class_getClassMethod函数，与class_copyMethodList不同的是，这两个函数都会去搜索父类的实现。</p>
<p>● class_copyMethodList函数，返回包含所有实例方法的数组，如果需要获取类方法，则可以使用class_copyMethodList(object_getClass(cls), &amp;count)(一个类的实例方法是定义在元类里面)。该列表不包含父类实现的方法。outCount参数返回方法的个数。在获取到列表后，我们需要使用free()方法来释放它。</p>
<p>● class_replaceMethod函数，该函数的行为可以分为两种：如果类中不存在name指定的方法，则类似于class_addMethod函数一样会添加方法；如果类中已存在name指定的方法，则类似于method_setImplementation一样替代原方法的实现。</p>
<p>● class_getMethodImplementation函数，该函数在向类实例发送消息时会被调用，并返回一个指向方法实现函数的指针。这个函数会比method_getImplementation(class_getInstanceMethod(cls, name))更快。返回的函数指针可能是一个指向runtime内部的函数，而不一定是方法的实际实现。例如，如果类实例无法响应selector，则返回的函数指针将是运行时消息转发机制的一部分。</p>
<p>● class_respondsToSelector函数，我们通常使用NSObject类的respondsToSelector:或instancesRespondToSelector:方法来达到相同目的。</p>
<p>协议(objc_protocol_list)</p>
<p>协议相关的操作包含以下函数：</p>
<p>// 添加协议</p>
<p>BOOL class_addProtocol ( Class cls, Protocol *protocol );</p>
<p>// 返回类是否实现指定的协议</p>
<p>BOOL class_conformsToProtocol ( Class cls, Protocol *protocol );</p>
<p>// 返回类实现的协议列表</p>
<p>Protocol <em> class_copyProtocolList ( Class cls, unsigned int </em>outCount );<br>● class_conformsToProtocol函数可以使用NSObject类的conformsToProtocol:方法来替代。</p>
<p>● class_copyProtocolList函数返回的是一个数组，在使用后我们需要使用free()手动释放。</p>
<p>版本(version)</p>
<p>版本相关的操作包含以下函数：</p>
<p>// 获取版本号</p>
<p>int class_getVersion ( Class cls );</p>
<p>// 设置版本号</p>
<p>void class_setVersion ( Class cls, int version );<br>其它</p>
<p>runtime还提供了两个函数来供CoreFoundation的tool-free bridging使用，即：</p>
<p>Class objc_getFutureClass ( const char *name );</p>
<p>void objc_setFutureClass ( Class cls, const char *name );<br>通常我们不直接使用这两个函数。</p>
<p>实例(Example)</p>
<p>上面列举了大量类操作的函数，下面我们写个实例，来看看这些函数的实例效果：</p>
<p>//———————————————————–</p>
<p>// MyClass.h</p>
<p>@interface MyClass : NSObject <nscopying, nscoding=""></nscopying,></p>
<p>@property (nonatomic, strong) NSArray *array;</p>
<p>@property (nonatomic, copy) NSString *string;</p>
<ul>
<li>(void)method1;</li>
</ul>
<ul>
<li>(void)method2;</li>
</ul>
<ul>
<li>(void)classMethod1;</li>
</ul>
<p>@end</p>
<p>//———————————————————–</p>
<p>// MyClass.m</p>
<p>#import “MyClass.h”</p>
<p>@interface MyClass () {</p>
<p>NSInteger       _instance1;</p>
<p>NSString    *   _instance2;</p>
<p>}</p>
<p>@property (nonatomic, assign) NSUInteger integer;</p>
<ul>
<li>(void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2;</li>
</ul>
<p>@end</p>
<p>@implementation MyClass</p>
<ul>
<li>(void)classMethod1 {</li>
</ul>
<p>}</p>
<ul>
<li>(void)method1 {</li>
</ul>
<p>NSLog(@”call method method1”);</p>
<p>}</p>
<ul>
<li>(void)method2 {</li>
</ul>
<p>}</p>
<ul>
<li>(void)method3WithArg1:(NSInteger)arg1 arg2:(NSString *)arg2 {</li>
</ul>
<p>NSLog(@”arg1 : %ld, arg2 : %@”, arg1, arg2);</p>
<p>}</p>
<p>@end</p>
<p>//———————————————————–</p>
<p>// main.h</p>
<p>#import “MyClass.h”</p>
<p>#import “MySubClass.h”</p>
<p>#import <objc runtime.h=""></objc></p>
<p>int main(int argc, const char * argv[]) {</p>
<p>@autoreleasepool {</p>
<p>MyClass *myClass = [[MyClass alloc] init];</p>
<p>unsigned int outCount = 0;</p>
<p>Class cls = myClass.class;</p>
<p>// 类名</p>
<p>NSLog(@”class name: %s”, class_getName(cls));</p>
<p>NSLog(@”==========================================================”);</p>
<p>// 父类</p>
<p>NSLog(@”super class name: %s”, class_getName(class_getSuperclass(cls)));</p>
<p>NSLog(@”==========================================================”);</p>
<p>// 是否是元类</p>
<p>NSLog(@”MyClass is %@ a meta-class”, (class_isMetaClass(cls) ? @”” : @”not”));</p>
<p>NSLog(@”==========================================================”);</p>
<p>Class meta_class = objc_getMetaClass(class_getName(cls));</p>
<p>NSLog(@”%s’s meta-class is %s”, class_getName(cls), class_getName(meta_class));</p>
<p>NSLog(@”==========================================================”);</p>
<p>// 变量实例大小</p>
<p>NSLog(@”instance size: %zu”, class_getInstanceSize(cls));</p>
<p>NSLog(@”==========================================================”);</p>
<p>// 成员变量</p>
<p>Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</p>
<p>for (int i = 0; i &lt; outCount; i++) {</p>
<p>Ivar ivar = ivars[i];</p>
<p>NSLog(@”instance variable’s name: %s at index: %d”, ivar_getName(ivar), i);</p>
<p>}</p>
<p>free(ivars);</p>
<p>Ivar string = class_getInstanceVariable(cls, “_string”);</p>
<p>if (string != NULL) {</p>
<p>NSLog(@”instace variable %s”, ivar_getName(string));</p>
<p>}</p>
<p>NSLog(@”==========================================================”);</p>
<p>// 属性操作</p>
<p>objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</p>
<p>for (int i = 0; i &lt; outCount; i++) {</p>
<p>objc_property_t property = properties[i];</p>
<p>NSLog(@”property’s name: %s”, property_getName(property));</p>
<p>}</p>
<p>free(properties);</p>
<p>objc_property_t array = class_getProperty(cls, “array”);</p>
<p>if (array != NULL) {</p>
<p>NSLog(@”property %s”, property_getName(array));</p>
<p>}</p>
<p>NSLog(@”==========================================================”);</p>
<p>// 方法操作</p>
<p>Method *methods = class_copyMethodList(cls, &amp;outCount);</p>
<p>for (int i = 0; i &lt; outCount; i++) {</p>
<p>Method method = methods[i];</p>
<p>NSLog(@”method’s signature: %s”, method_getName(method));</p>
<p>}</p>
<p>free(methods);</p>
<p>Method method1 = class_getInstanceMethod(cls, @selector(method1));</p>
<p>if (method1 != NULL) {</p>
<p>NSLog(@”method %s”, method_getName(method1));</p>
<p>}</p>
<p>Method classMethod = class_getClassMethod(cls, @selector(classMethod1));</p>
<p>if (classMethod != NULL) {</p>
<p>NSLog(@”class method : %s”, method_getName(classMethod));</p>
<p>}</p>
<p>NSLog(@”MyClass is%@ responsd to selector: method3WithArg1:arg2:”, class_respondsToSelector(cls, @selector(method3WithArg1:arg2:)) ? @”” : @” not”);</p>
<p>IMP imp = class_getMethodImplementation(cls, @selector(method1));</p>
<p>imp();</p>
<p>NSLog(@”==========================================================”);</p>
<p>// 协议</p>
<p>Protocol <em> __unsafe_unretained </em> protocols = class_copyProtocolList(cls, &amp;outCount);</p>
<p>Protocol * protocol;</p>
<p>for (int i = 0; i &lt; outCount; i++) {</p>
<p>protocol = protocols[i];</p>
<p>NSLog(@”protocol name: %s”, protocol_getName(protocol));</p>
<p>}</p>
<p>NSLog(@”MyClass is%@ responsed to protocol %s”, class_conformsToProtocol(cls, protocol) ? @”” : @” not”, protocol_getName(protocol));</p>
<p>NSLog(@”==========================================================”);</p>
<p>}</p>
<p>return 0;</p>
<p>}<br>这段程序的输出如下：</p>
<p>2014-10-22 19:41:37.452 RuntimeTest[3189:156810] class name: MyClass</p>
<p>2014-10-22 19:41:37.453 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.454 RuntimeTest[3189:156810] super class name: NSObject</p>
<p>2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass is not a meta-class</p>
<p>2014-10-22 19:41:37.454 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.454 RuntimeTest[3189:156810] MyClass’s meta-class is MyClass</p>
<p>2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance size: 48</p>
<p>2014-10-22 19:41:37.455 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable’s name: _instance1 at index: 0</p>
<p>2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable’s name: _instance2 at index: 1</p>
<p>2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable’s name: _array at index: 2</p>
<p>2014-10-22 19:41:37.455 RuntimeTest[3189:156810] instance variable’s name: _string at index: 3</p>
<p>2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instance variable’s name: _integer at index: 4</p>
<p>2014-10-22 19:41:37.463 RuntimeTest[3189:156810] instace variable _string</p>
<p>2014-10-22 19:41:37.463 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property’s name: array</p>
<p>2014-10-22 19:41:37.463 RuntimeTest[3189:156810] property’s name: string</p>
<p>2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property’s name: integer</p>
<p>2014-10-22 19:41:37.464 RuntimeTest[3189:156810] property array</p>
<p>2014-10-22 19:41:37.464 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method’s signature: method1</p>
<p>2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method’s signature: method2</p>
<p>2014-10-22 19:41:37.464 RuntimeTest[3189:156810] method’s signature: method3WithArg1:arg2:</p>
<p>2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method’s signature: integer</p>
<p>2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method’s signature: setInteger:</p>
<p>2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method’s signature: array</p>
<p>2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method’s signature: string</p>
<p>2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method’s signature: setString:</p>
<p>2014-10-22 19:41:37.465 RuntimeTest[3189:156810] method’s signature: setArray:</p>
<p>2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method’s signature: .cxx_destruct</p>
<p>2014-10-22 19:41:37.466 RuntimeTest[3189:156810] method method1</p>
<p>2014-10-22 19:41:37.466 RuntimeTest[3189:156810] class method : classMethod1</p>
<p>2014-10-22 19:41:37.466 RuntimeTest[3189:156810] MyClass is responsd to selector: method3WithArg1:arg2:</p>
<p>2014-10-22 19:41:37.467 RuntimeTest[3189:156810] call method method1</p>
<p>2014-10-22 19:41:37.467 RuntimeTest[3189:156810] ==========================================================</p>
<p>2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCopying</p>
<p>2014-10-22 19:41:37.467 RuntimeTest[3189:156810] protocol name: NSCoding</p>
<p>2014-10-22 19:41:37.467 RuntimeTest[3189:156810] MyClass is responsed to protocol NSCoding</p>
<p>2014-10-22 19:41:37.468 RuntimeTest[3189:156810] ==========================================================<br>动态创建类和对象</p>
<p>runtime的强大之处在于它能在运行时创建类和对象。</p>
<p>动态创建类</p>
<p>动态创建类涉及到以下几个函数：</p>
<p>// 创建一个新类和元类</p>
<p>Class objc_allocateClassPair ( Class superclass, const char *name, size_t extraBytes );</p>
<p>// 销毁一个类及其相关联的类</p>
<p>void objc_disposeClassPair ( Class cls );</p>
<p>// 在应用中注册由objc_allocateClassPair创建的类</p>
<p>void objc_registerClassPair ( Class cls );<br>● objc_allocateClassPair函数：如果我们要创建一个根类，则superclass指定为Nil。extraBytes通常指定为0，该参数是分配给类和元类对象尾部的索引ivars的字节数。</p>
<p>为了创建一个新类，我们需要调用objc_allocateClassPair。然后使用诸如class_addMethod，class_addIvar等函数来为新创建的类添加方法、实例变量和属性等。完成这些后，我们需要调用objc_registerClassPair函数来注册类，之后这个新类就可以在程序中使用了。</p>
<p>实例方法和实例变量应该添加到类自身上，而类方法应该添加到类的元类上。</p>
<p>● objc_disposeClassPair函数用于销毁一个类，不过需要注意的是，如果程序运行中还存在类或其子类的实例，则不能调用针对类调用该方法。</p>
<p>在前面介绍元类时，我们已经有接触到这几个函数了，在此我们再举个实例来看看这几个函数的使用。</p>
<p>Class cls = objc_allocateClassPair(MyClass.class, “MySubClass”, 0);<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>class_addMethod(cls, @selector(submethod1), (IMP)imp_submethod1, “v@:”);<br>class_replaceMethod(cls, @selector(method1), (IMP)imp_submethod1, “v@:”);<br>class_addIvar(cls, “_ivar1”, sizeof(NSString <em>), log(sizeof(NSString </em>)), “i”);</p>
<p>objc_property_attribute_t type = {“T”, “@\”NSString\””};<br>objc_property_attribute_t ownership = { “C”, “” };<br>objc_property_attribute_t backingivar = { “V”, “_ivar1”};<br>objc_property_attribute_t attrs[] = {type, ownership, backingivar};</p>
<p>class_addProperty(cls, “property2”, attrs, 3);<br>objc_registerClassPair(cls);</p>
<p>id instance = [[cls alloc] init];<br>[instance performSelector:@selector(submethod1)];<br>[instance performSelector:@selector(method1)];<br>程序的输出如下：</p>
<p>2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1</p>
<p>2014-10-23 11:35:31.006 RuntimeTest[3800:66152] run sub method 1<br>动态创建对象</p>
<p>动态创建对象的函数如下：</p>
<p>// 创建类实例</p>
<p>id class_createInstance ( Class cls, size_t extraBytes );</p>
<p>// 在指定位置创建类实例</p>
<p>id objc_constructInstance ( Class cls, void *bytes );</p>
<p>// 销毁类实例</p>
<p>void * objc_destructInstance ( id obj );<br>● class_createInstance函数：创建实例时，会在默认的内存区域为类分配内存。extraBytes参数表示分配的额外字节数。这些额外的字节可用于存储在类定义中所定义的实例变量之外的实例变量。该函数在ARC环境下无法使用。</p>
<p>调用class_createInstance的效果与+alloc方法类似。不过在使用class_createInstance时，我们需要确切的知道我们要用它来做什么。在下面的例子中，我们用NSString来测试一下该函数的实际效果：</p>
<p>id theObject = class_createInstance(NSString.class, sizeof(unsigned));<br>1<br>2<br>3<br>4<br>5<br>6<br>id str1 = [theObject init];</p>
<p>NSLog(@”%@”, [str1 class]);</p>
<p>id str2 = [[NSString alloc] initWithString:@”test”];<br>NSLog(@”%@”, [str2 class]);<br>输出结果是：</p>
<p>2014-10-23 12:46:50.781 RuntimeTest[4039:89088] NSString</p>
<p>2014-10-23 12:46:50.781 RuntimeTest[4039:89088] <strong>NSCFConstantString<br>可以看到，使用class_createInstance函数获取的是NSString实例，而不是类簇中的默认占位符类</strong>NSCFConstantString。</p>
<p>● objc_constructInstance函数：在指定的位置(bytes)创建类实例。</p>
<p>● objc_destructInstance函数：销毁一个类的实例，但不会释放并移除任何与其相关的引用。</p>
<p>实例操作函数</p>
<p>实例操作函数主要是针对我们创建的实例对象的一系列操作函数，我们可以使用这组函数来从实例对象中获取我们想要的一些信息，如实例对象中变量的值。这组函数可以分为三小类：</p>
<p>1.针对整个对象进行操作的函数，这类函数包含</p>
<p>// 返回指定对象的一份拷贝</p>
<p>id object_copy ( id obj, size_t size );</p>
<p>// 释放指定对象占用的内存</p>
<p>id object_dispose ( id obj );<br>有这样一种场景，假设我们有类A和类B，且类B是类A的子类。类B通过添加一些额外的属性来扩展类A。现在我们创建了一个A类的实例对象，并希望在运行时将这个对象转换为B类的实例对象，这样可以添加数据到B类的属性中。这种情况下，我们没有办法直接转换，因为B类的实例会比A类的实例更大，没有足够的空间来放置对象。此时，我们就要以使用以上几个函数来处理这种情况，如下代码所示：</p>
<p>NSObject *a = [[NSObject alloc] init];</p>
<p>id newB = object_copy(a, class_getInstanceSize(MyClass.class));</p>
<p>object_setClass(newB, MyClass.class);</p>
<p>object_dispose(a);<br>2.针对对象实例变量进行操作的函数，这类函数包含：</p>
<p>// 修改类实例的实例变量的值</p>
<p>Ivar object_setInstanceVariable ( id obj, const char <em>name, void </em>value );</p>
<p>// 获取对象实例变量的值</p>
<p>Ivar object_getInstanceVariable ( id obj, const char <em>name, void *</em>outValue );</p>
<p>// 返回指向给定对象分配的任何额外字节的指针</p>
<p>void * object_getIndexedIvars ( id obj );</p>
<p>// 返回对象中实例变量的值</p>
<p>id object_getIvar ( id obj, Ivar ivar );</p>
<p>// 设置对象中实例变量的值</p>
<p>void object_setIvar ( id obj, Ivar ivar, id value );<br>如果实例变量的Ivar已经知道，那么调用object_getIvar会比object_getInstanceVariable函数快，相同情况下，object_setIvar也比object_setInstanceVariable快。</p>
<p>3.针对对象的类进行操作的函数，这类函数包含：</p>
<p>// 返回给定对象的类名</p>
<p>const char * object_getClassName ( id obj );</p>
<p>// 返回对象的类</p>
<p>Class object_getClass ( id obj );</p>
<p>// 设置对象的类</p>
<p>Class object_setClass ( id obj, Class cls );<br>获取类定义</p>
<p>Objective-C动态运行库会自动注册我们代码中定义的所有的类。我们也可以在运行时创建类定义并使用objc_addClass函数来注册它们。runtime提供了一系列函数来获取类定义相关的信息，这些函数主要包括：</p>
<p>// 获取已注册的类定义的列表</p>
<p>int objc_getClassList ( Class *buffer, int bufferCount );</p>
<p>// 创建并返回一个指向所有已注册类的指针列表</p>
<p>Class <em> objc_copyClassList ( unsigned int </em>outCount );</p>
<p>// 返回指定类的类定义</p>
<p>Class objc_lookUpClass ( const char *name );</p>
<p>Class objc_getClass ( const char *name );</p>
<p>Class objc_getRequiredClass ( const char *name );</p>
<p>// 返回指定类的元类</p>
<p>Class objc_getMetaClass ( const char *name );<br>● objc_getClassList函数：获取已注册的类定义的列表。我们不能假设从该函数中获取的类对象是继承自NSObject体系的，所以在这些类上调用方法是，都应该先检测一下这个方法是否在这个类中实现。</p>
<p>下面代码演示了该函数的用法：</p>
<p>int numClasses;</p>
<p>Class * classes = NULL;</p>
<p>numClasses = objc_getClassList(NULL, 0);<br>if (numClasses &gt; 0) {<br>classes = malloc(sizeof(Class) * numClasses);<br>numClasses = objc_getClassList(classes, numClasses);</p>
<p>NSLog(@”number of classes: %d”, numClasses);</p>
<p>for (int i = 0; i &lt; numClasses; i++) {</p>
<p>Class cls = classes[i];<br>NSLog(@”class name: %s”, class_getName(cls));<br>}</p>
<p>free(classes);<br>}<br>输出结果如下：</p>
<p>2014-10-23 16:20:52.589 RuntimeTest[8437:188589] number of classes: 1282</p>
<p>2014-10-23 16:20:52.589 RuntimeTest[8437:188589] class name: DDTokenRegexp</p>
<p>2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: _NSMostCommonKoreanCharsKeySet</p>
<p>2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: OS_xpc_dictionary</p>
<p>2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSFileCoordinator</p>
<p>2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: NSAssertionHandler</p>
<p>2014-10-23 16:20:52.590 RuntimeTest[8437:188589] class name: PFUbiquityTransactionLogMigrator</p>
<p>2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSNotification</p>
<p>2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: NSKeyValueNilSetEnumerator</p>
<p>2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: OS_tcp_connection_tls_session</p>
<p>2014-10-23 16:20:52.591 RuntimeTest[8437:188589] class name: _PFRoutines</p>
<p>……还有大量输出<br>● 获取类定义的方法有三个：objc_lookUpClass, objc_getClass和objc_getRequiredClass。如果类在运行时未注册，则objc_lookUpClass会返回nil，而objc_getClass会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。而objc_getRequiredClass函数的操作与objc_getClass相同，只不过如果没有找到类，则会杀死进程。</p>
<p>● objc_getMetaClass函数：如果指定的类没有注册，则该函数会调用类处理回调，并再次确认类是否注册，如果确认未注册，再返回nil。不过，每个类定义都必须有一个有效的元类定义，所以这个函数总是会返回一个元类定义，不管它是否有效。</p>
<p>小结</p>
<p>在这一章中我们介绍了Runtime运行时中与类和对象相关的数据结构，通过这些数据函数，我们可以管窥Objective-C底层面向对象实现的一些信息。另外，通过丰富的操作函数，可以灵活地对这些数据进行操作。</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/06/23/ios-Runtime机制/">
    <time datetime="2015-06-23T14:01:19.000Z" class="entry-date">
        2015-06-23
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
</article>






  
    <article id="post-ios页面跳转机制" class="post-ios页面跳转机制 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2015/06/16/ios页面跳转机制/">ios页面跳转机制</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2015/06/16/ios页面跳转机制/" data-id="ciq0acdul00048as697z9l6s3" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>常用的就两种 一种通过导航，一种直接跳</p>
<p>第一种 直接跳转 思路大致就是new一个目的页面，然后设置下页面跳转动画 中间还可以做点目的页面的数据初始化:</p>
<p>ValueInputView *valueView = [[ValueInputView alloc] initWithNibName:@”ValueInputView”bundle:[NSBundle mainBundle]];</p>
<p>valueView.delegate = self;</p>
<p>[valueView setModalTransitionStyle:UIModalTransitionStyleCoverVertical];</p>
<p>[self presentModalViewController:valueView animated:YES];</p>
<p>//返回 </p>
<p>[self dismissModalViewControllerAnimated:YES];</p>
<p>第二:</p>
<p>利用UINavigationController，调用pushViewController，进行跳转；这种采用压栈和出栈的方式，进行Controller的管理。调用popViewControllerAnimated方法可以返回</p>
<p>PickImageViewController *ickImageViewController = [[PickImageViewController alloc] init]; </p>
<p>[self.navigationController pushViewController: ickImageViewController animated:true]; </p>
<p>四种setModalTransitionStyle风格</p>
<p>UIModalTransitionStyleCoverVertical 从底部滑入<br>UIModalTransitionStyleFlipHorizontal,水平翻转进入<br>UIModalTransitionStyleCrossDissolve,交叉溶解<br>UIModalTransitionStylePartialCurl,翻页</p>
<p>场景切换</p>
<p>多个场景之间切换的样式(Style)总共有5个：<br>Modal(模态) – 过渡到另一个场景，以完成一项任务。任务完成后，将关闭该场景，并返回到原来的场景。<br>Push(压入) – 创建一个场景链，用户可在其中前后移动。用于导航视图控制器。<br>Replace(替换，仅适用于iPad) – 替换当前场景，用于一些iPad特有的视图控制器。<br>Popover(弹出框，仅适用于iPad) – 一个带箭头的弹出框。<br>Custome(自定义) – 通过编译在场景之间进行自定义过渡。</p>
<p>过渡类型(Transition)是从一个场景切换到另一个场景时播放的动画。有4个选项：<br>Cover Vertical – 新场景从下向上移动，逐渐覆盖旧场景。<br>Flip Horizontal – 视图水平翻转，以显示背面的新场景。<br>Cross Dissolve – 旧场景淡出，新场景淡入。<br>Partial Curl – 旧场景像书页一样翻开，显示下面的新场景。</p>
<p>在iPad应用程序中，还会多出一个Presentation属性，它决定了模态视图在屏幕上的显示方式。有4种显示样式：<br>Form Sheet(表单) – 将场景调整到比屏幕小(不管朝向)，并在当前场景后面显示原始场景，这几乎相当于在一个iPad窗口中显示。<br>Page Sheet(页面) – 调整场景大小，使其以纵向格式显示。<br>Full Screen(全屏) – 调整场景大小，使其覆盖整个屏幕。<br>Current Context(当前上下文) – 以原始场景的显示方式展示场景。</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2015/06/16/ios页面跳转机制/">
    <time datetime="2015-06-16T12:02:52.000Z" class="entry-date">
        2015-06-16
    </time>
</a>
    
    
    </footer>
</article>






  
    <article id="ios提交应用至app-store流程" class="ios提交应用至app-store流程 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/10/15/store流程/">store流程</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/10/15/store流程/" data-id="ciq0acdun00068as638z2ces4" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>iOS提交应用至APP Store流程</p>
<p>一、申请苹果开发者账号</p>
<p>首先需要申请苹果开发者账号才能在APP Store里发布应用。</p>
<p>1     准备材料</p>
<p>1.1     公司的邓白氏编码</p>
<p>给苹果公司发个邮件（或则直接拨打苹果开发者服务热线:4006 701 855 2）。他会给你提供免费注册邓白氏码的网址。直接注册就好.</p>
<p><a href="https://developer.apple.com/ios/enroll/dunsLookupForm.action" target="_blank" rel="external">https://developer.apple.com/ios/enroll/dunsLookupForm.action</a></p>
<p>1.2     公司的营业执照副本和公司中英文名对照证明</p>
<p>证明你公司英文名的信件（这个其实只要一句话说一下就好了，比如你就写此信标明我们公司的英文名是 XXXX就ok了），公司盖章。</p>
<p>很多国内公司都无法传真到国外，这个时候你可以使用网络传真，推荐用 <a href="http://faxzero.com/" target="_blank" rel="external">http://faxzero.com/</a> </p>
<p>1.3     一张开通VISA或MASTER的信用卡</p>
<p>可以是个人的，提交帐号给Apple代扣款（$99美金）</p>
<p>2     步骤</p>
<p>2.1     申请邓白氏码</p>
<p>首先要申请邓白氏码,在申请的第二天你就会接到电话，跟邮件。那个邮件不是邓白氏码。而是你的申请码。最好是留着吧。是个十位码, 大约中午的时间你会接到华夏邓白氏的电话。就是跟你核对一下资料。大约晚上的时候，你就会接受到新的邮件。那个才是邓白氏码。这个邓白氏码是无效的，需要等至少14天后才可以使用.</p>
<p>等14天后，去ios develop网站申请公司开发者账号，如果提示邓白氏码无效，则给苹果开发者中心打电话,告诉他邓白氏无效，她会处理（可能是和邓白氏联系）过几天（具体几天客服会告诉你）邓白氏码就可用了。</p>
<p>然后你会填公司信息的时候可能会遇到提示说公司信息和苹果数据库中的信息不符（其实是邓白氏的数据库与苹果的数据库未同步），不要着急，接着打电话，她会告诉你在苹果数据库中的公司信息。然后告诉你一个邓白氏的联系邮箱（这个邮箱是邓白氏专为申请苹果公司开发者账号使用的）你把苹果数据库中的公司信息发给邓白氏让它更改。再等14天，再去申请，一切就ok了.这种情况不是每个人都会遇到。如果信息相符，那是最好的了。不用再等14天了。</p>
<p>PS：耐心等待14天后再注册，邓白氏码有尝试次数限制。</p>
<p>2.2     信息注册</p>
<p>申请完邓白氏码后,就是去注册iOS公司开发者账号了, 到 <a href="http://developer.apple.com/programs/ios/" target="_blank" rel="external">http://developer.apple.com/programs/ios/</a> 这个开发者账号注册入口，开始enroll(注册)。如果你已经有apple的个人账号了，那你可以将你的个人账号作为开发者账号，不然你就新申请一个账号。</p>
<p>当让你选择你是注册成为个人或者公司时，请选择公司。注册是填信息一定要注意，不要乱填，要真是填写，不然后面验证时你就麻烦了。当问你你要选择那个开发平台时，你要选择ios.</p>
<p>当你注册完个人apple账号，就会转入公司信息填写。公司信息填写也要真实填写，这个是会和你的公司营业执照挂钩的，后面审核会用到。注册信息只能是用英文的，所以对于没有英文名的公司和地址，都要先去处理这些东西了。填写完公司信息，下一步就是填写邮件（这个后期会用来跟apple开发者中心联系）和代表人（你可以选择你自己或者你老板的名称，都可以）。接下来就是等待对方审核了，这一般会等待1-2天，如果审核过了，对方会给你发邮件。</p>
<p>PS：代表人，及legal entity字段，必须与申请邓白氏码时填写的一致，否则无法通过，这个即是上面说的数据库信息不符的字段。</p>
<p>2.3     传真资料</p>
<p>apple那边如果通过了你的公司信息，就会发邮件要你传送资料过去（对方会用 devenroll@apple.com这个邮件）。你需要传送你的公司营业执照，一封证明你公司英文名的信件（这个其实只要一句话说一下就好了，比如你就写此信标明我们公司的英文名是 XXXX就ok了），公司盖章。然后传真过去。很多国内公司都无法传真到国外，这个时候你可以使用网络传真（我就是这么做的），推荐用 <a href="http://faxzero.com/" target="_blank" rel="external">http://faxzero.com/</a> </p>
<p>这一步是最麻烦的，要等3-4天的审核期</p>
<p>PS：实在不行可以传真到亚洲苹果并请他们转交苹果开发者团队。 不过苹果不推荐这么做。</p>
<p>2.4     电话验证</p>
<p>如果你的传真对方通过了，对方会发邮件给你，让你打电话进行验证。里面有个中文区电话，你可以选择打这个电话。</p>
<p>2.5     付款</p>
<p>电话验证完，一般几分钟你就会收到邮件让你付款。apple是不开通国内在线付款的，所以，你得填一张purchaseform。你要准备一张跨国的信用卡（比如visa，或者mastercard等），把你的信用卡信息填进去，然后吧purchase form再次传真过去。基本上等2天后，如果对方通过你的付款，你就正式开通啦。</p>
<p>2.6     激活账号</p>
<p>付完款后，账号基本就开通了，然后苹果会发一个激活账号的邮件，邮件中有激活码，直接点激活码去激活。</p>
<p>到这里开发者账号申请结束。</p>
<p>二、申请APPID</p>
<p>1 添加BundleID<br>最后确认提交就好了。</p>
<p>2 连接iTunesConnect</p>
<p>刚激活的账号暂时无法登录iTunesConnect，需要等苹果给你发一封关于可以登录的邮件后才能登录，否则会说你无权限。</p>
<p>3 创建新应用</p>
<p>3.1  登录iTunes Connect后，点击“管理你的应用” 进入管理页。</p>
<p>3.2  点击“添加新的应用”按钮</p>
<p>前两个就不说了，第三个SKUNumber什么意思我也不知道，为了保持唯一，并好记，就和BundleID一样。第四个BundleID一经选择，就不能更改，所以要谨慎选择。</p>
<p>3.3 设置生效时间和价格</p>
<p>这里的价格是按层级来的，并不是具体的多少钱，Tier 1为1美元，在中国商店就相当于6元人民币。</p>
<p>注意下面还有一个你的APP发布的商店，默认是所有商店都发布。</p>
<p>3.4 设置APP信息</p>
<p>包括版本号，所有权</p>
<p>还有APP的内容描述，默认都选择None，根据自己的APP实际情况</p>
<p>然后是一些元数据，关于APP的描述，用于显示在APPStore中。关键字用于用户可以利用这些关键字搜索到你的APP。SupportURL是当你的APP出现问题时，用户可以联系的地址。</p>
<p>接着是APPStore审核的反馈信息，包括联系人信息，以及提供APP的测试账号。</p>
<p>最后是上传Icon、屏幕截图，屏幕截图不超过5张。</p>
<p>提交，就有APP ID了。</p>
<p>4      PS：</p>
<p>注意现在的状态为Preparefor Upload，点击ViewDetails, 进入后点击“Readyto Upload    Binary”</p>
<p>接着会询问你是否使用加密功能，选择后保存。</p>
<p>现在的状态为“WaitingFor Upload”了。</p>
<p>三、上传应用</p>
<p>1 创建CSR文件</p>
<p>1.1 打开电脑中的钥匙串</p>
<p>1.2 选择导航栏中下面的选项</p>
<p>1.3 然后输入用户邮箱，名字，选择保存到硬盘。</p>
<p>2 创建发布证书</p>
<p>2.1 选择App Store</p>
<p>2.2 上传刚刚创建的CSR文件</p>
<p>2.3 上传后证书创建成功，下载到本地。</p>
<p>2.4 双击该文件，加入到钥匙串中。</p>
<p>3 创建ProvisioningProfiles</p>
<p>3.1 选择APP Store                              </p>
<p>3.2 选择App ID</p>
<p>3.3 选择证书</p>
<p>3.4 命名</p>
<p>3.5 最后提交后下载ProvisioningProfiles文件到本地，双击打开添加到Xcode中。</p>
<p>4    Xcode设置</p>
<p>4.1 设置target</p>
<p>这里的BundleIdentifier必须和前面申请的BundleID一致；版本号也必须和前面申请AppID时的版本号一致。</p>
<p>4.2 修改签名文件，必须选择前面创建的ProvisioningProfiles文件</p>
<p>4.3 添加发布配置</p>
<p>如果没有添加一个</p>
<p>4.4 编辑Scheme</p>
<p>选择Distribution</p>
<p>4.5 clean一下工程 </p>
<p>4.6 Archive</p>
<p>会跳入到Archives界面</p>
<p>选择下面你要发布的程序，点发布就行了。中间会需要一段时间上传应用，以及检测你的应用是否违反苹果的一些规则。没有问题的话就会提交成功。</p>
<p>四、存在的问题</p>
<p>1 调用私有API</p>
<p>这个是因为我使用的百度地图的SDK，比较老，出现的问题。原因是现在获取设备的UDID已经是私有方法了。</p>
<p>五、常用的代码</p>
<p>1      检查更新</p>
<p>-(void)getUpdate</p>
<p>{</p>
<p>NSDictionary *infoDict = [[NSBundlemainBundle] infoDictionary];</p>
<p>NSString *nowVersion = [infoDictobjectForKey:@”CFBundleVersion”];</p>
<p>NSURL url = [NSURLURLWithString:@”<a href="http://itunes.apple.com/lookup?id=*******" target="_blank" rel="external">http://itunes.apple.com/lookup?id=*******</a>“];</p>
<p>NSString * file =  [NSStringstringWithContentsOfURL:url encoding:NSUTF8StringEncoding error:nil];</p>
<p>//“version”:”1.0”</p>
<p>NSRange substr = [file rangeOfString:@”\”version\”:\””];</p>
<p>NSRange range1 = NSMakeRange(substr.location+substr.length,10);</p>
<p>NSRange substr2 =[file rangeOfString:@”\”” options:NULL range:range1];</p>
<p>NSRange range2 = NSMakeRange(substr.location+substr.length, substr2.location-substr.location-substr.length);</p>
<p>NSString *newVersion =[filesubstringWithRange:range2];</p>
<p>if([nowVersion isEqualToString:newVersion]==NO)</p>
<p>{</p>
<p>UIAlertView *alert = [[UIAlertViewalloc] initWithTitle:nilmessage:@”版本有更新”delegate:selfcancelButtonTitle:@”取消”otherButtonTitles:@”更新”,nil];</p>
<p>[alert show];</p>
<p>[alert release];</p>
<p>} else {</p>
<p>UIAlertView *alert = [[UIAlertViewalloc] initWithTitle:nilmessage:@”已是最新版本”delegate:selfcancelButtonTitle:@”确定”otherButtonTitles:nil];</p>
<p>[alert show];</p>
<p>[alert release];</p>
<p>}</p>
<p>}</p>
<ul>
<li>(void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex</li>
</ul>
<p>{</p>
<p>if(buttonIndex==1)</p>
<p>{</p>
<p>//link地址，下载地址</p>
<p>NSURL url = [NSURLURLWithString:@”<a href="https://itunes.apple.com/us/app/***-***-***/id*******?ls=1&amp;mt=8" target="_blank" rel="external">https://itunes.apple.com/us/app/***-***-***/id*******?ls=1&amp;mt=8</a>“];</p>
<p>[[UIApplication sharedApplication]openURL:url];</p>
<p>}</p>
<p>}</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/10/15/store流程/">
    <time datetime="2014-10-15T02:43:15.000Z" class="entry-date">
        2014-10-15
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
</article>






  
    <article id="ios-nonatomic、-synthesize、-property、-dynamic" class="ios-nonatomic、-synthesize、-property、-dynamic post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title">
      <a class="article-title" href="/2014/07/15/nonatomic、-synthesize、-property、-dynamic/">关键字介绍：nonatomic、@synthesize、@property、@dynamic</a>
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/07/15/nonatomic、-synthesize、-property、-dynamic/" data-id="ciq0acduq00088as6mx6tabhi" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>1.#synthesize关键字: 根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量 。</p>
<p>2.@implementation 关键字，表明类的实现 @end 结束</p>
<p>3.self 关键字 ：类似于java中的this，是隐藏参数，指向当前调用方法的类。</p>
<p>super 关键字 ：调用父类的方法。</p>
<p>self = [superinit]  这里不是判断self与[superinit]是否相等，而是判断是否可以成功初始化。[super init]：父类初始化成功的话，通过=给self，这样self成为一个非空对象，整个来说即非false(非NO)。</p>
<p>#import 告诉预处理器,将头文件的内容包含到本文件中. OC 中的import 能保证头文件只会被包含一次 .@interface关键字：声明一个Student类。@end 结束声明.</p>
<p>冒号:表示继承 后面跟的是父类.  </p>
<p>NSObject是大多数对象都会用到的内存管理,和初始化框架,以及反射和类型操作. 相 当于Object。</p>
<p>NS是NextSTEP缩写,表示这个函数来自Cocoa工具包。</p>
<p>声明全局变量 , 与C中一样。</p>
<p>property关键字：设置成员变量的属性（有读／写，赋值assign,retain,copy ,以及对多线程的支持nonatomic）。</p>
<p>声明一个方法，格式是  –(返回值) 方法关键字1 : (参数类型)参数名 方法关键字2 : (参数类型)参数名 …… （在读方法的时候就可以先找方法关键字来确定参数）。</p>
<ul>
<li>减号是实例方法， + 是类方法</li>
</ul>
<ol>
<li><p>另一个初始化方法中调用已有的初始化方法  这种概念被称为Designated Initializer.</p>
</li>
<li><p>NSLog是OC中的标准输出, 附加输出当时日期, 时间, 应用程序名称 . 使用NSLog()输出任意对象的值时,都会使用%@格式说明。在使用这个说明符时,对象通过一个名为description的方法提供自己的NSLog()格式。 </p>
</li>
</ol>
<p>使用@property配合@synthesize可以让编译器自动实现getter/setter方法，使用的时候也很方便，可以直接使用“对象.属性”的方法调用;如果我们想要”对象.方法“的方式来调用一个方法并获取到方法的返回值，那就需要使用@property配合@dynamic了</p>
<p>使用@dynamic关键字是告诉编译器由我们自己来实现访问方法。如果使用的是@synthesize，那么这个工作编译器就会帮你实现了。</p>
<p>readonly此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用@synthesize关键字，也是有读取器方法被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。</p>
<p>readwrite此标记说明属性会被当成读写的，这也是默认属性。设置器和读取器都需要在@implementation中实现。如果使用@synthesize关键字，读取器和设置器都会被解析。</p>
<p>nonatomic：非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问。<br>atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。<br>atomic<br>设置成员变量的@property属性时，默认为atomic，提供多线程安全。<br>在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。加了atomic，setter函数会变成下面这样：<br>{lock}<br>if (property != newValue) {<br>[property release];<br>property = [newValue retain];<br>}<br>{unlock}<br>nonatomic<br>禁止多线程，变量保护，提高性能。<br>atomic是Objc使用的一种线程保护技术，基本上来讲，是防止在写未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。<br>指出访问器不是原子操作，而默认地，访问器是原子操作。这也就是说，在多线程环境下，解析的访问器提供一个对属性的安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是别的线程也正在对其进行访问。如果你不指定 nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。<br>assign: 简单赋值，不更改索引计数<br>对基础数据类型 （例如NSInteger，CGFloat）和C数据类型（int, float, double, char, 等）       适用简单数据类型<br>此标记说明设置器直接进行赋值，这也是默认值。在使用垃圾收集的应用程序中，如果你要一个属性使用assign，且这个类符合NSCopying协             议，你就要明确指出这个标记，而不是简单地使用默认值，否则的话，你将得到一个编译警告。这再次向编译器说明你确实需要赋值，即使它是           可拷贝的。<br>copy:建立一个索引计数为1的对象，然后释放旧对象                对NSString<br>对NSString 它指出，在赋值时使用传入值的一份拷贝。拷贝工作由copy方法执行，此属性只对那些实行了NSCopying协议的对象类型有效。更深入的讨论，请参考“复制”部分。<br>retain:释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1<br>对其他NSObject和其子类<br>对参数进行release旧值，再retain新值<br>指定retain会在赋值时唤醒传入值的retain消息。此属性只能用于Objective-C对象类型，而不能用于Core Foundation对象。(原因很明显，retain会增加对象的引用计数，而基本数据类型或者Core Foundation对象都没有引用计数——译者注)。<br>注意: 把对象添加到数组中时，引用计数将增加对象的引用次数+1。<br>retain的实际语法为：</p>
<ul>
<li>(void)setName:(NSString *)newName {<br>if (name != newName) {<br>[name release];<br>name = [newName retain];<br>// name’s retain count has been bumped up by 1<br>}<br>}<br>copy与retain：<br>Copy其实是建立了一个相同的对象，而retain不是：<br>比如一个NSString对象，地址为0×1111，内容为@”STR”<br>Copy到另外一个NSString之后，地址为0×2222，内容相同，新的对象retain为1，旧有对象没有变化<br>retain到另外一个NSString之后，地址相同（建立一个指针，指针拷贝），内容当然相同，这个对象的retain值+1<br>也就是说，retain是指针拷贝，copy是内容拷贝。哇，比想象的简单多了…</li>
</ul>
<p>retain的set方法应该是浅复制，copy的set方法应该是深复制了<br>copy另一个用法：<br>copy是内容的拷贝  ,对于像NSString,的确是这样.<br>但是,如果是copy的是一个NSArray呢?比如,<br>NSArray <em>array = [NSArray arrayWithObjects:@”hello”,@”world”,@”baby”];<br>NSArray </em>array2 = [array copy];<br>这个时候,,系统的确是为array2开辟了一块内存空间,但是我们要认识到的是,array2中的每个元素,,只是copy了指向array中相对应元素的指针.这便是所谓的”浅复制”.<br>assign与retain：</p>
<ol>
<li>接触过C，那么假设你用malloc分配了一块内存，并且把它的地址赋值给了指针a，后来你希望指针b也共享这块内存，于是你又把a赋值给（assign）了b。此时a和b指向同一块内存，请问当a不再需要这块内存，能否直接释放它？答案是否定的，因为a并不知道b是否还在使用这块内存，如果a释放了，那么b在使用这块内存的时候会引起程序crash掉。</li>
<li>了解到1中assign的问题，那么如何解决？最简单的一个方法就是使用引用计数（reference counting），还是上面的那个例子，我们给那块内存设一个引用计数，当内存被分配并且赋值给a时，引用计数是1。当把a赋值给b时引用计数增加到2。这时如果a不再使用这块内存，它只需要把引用计数减1，表明自己不再拥有这块内存。b不再使用这块内存时也把引用计数减1。当引用计数变为0的时候，代表该内存不再被任何指针所引用，系统可以把它直接释放掉。<br>总结：上面两点其实就是assign和retain的区别，assign就是直接赋值，从而可能引起1中的问题，当数据为int, float等原生类型时，可以使用assign。retain就如2中所述，使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收。</li>
</ol>
<p>NSString <em>pt = [[NSString alloc] initWithString:@”abc”];<br>上面一段代码会执行以下两个动作<br>1 在堆上分配一段内存用来存储@”abc”  比如：内存地址为：0X1111 内容为 “abc”<br>2 在栈上分配一段内存用来存储pt  比如：地址为：0Xaaaa 内容自然为0X1111<br>下面分别看下assign retain copy<br>assign的情况：NSString </em>newPt = [pt assing];<br>此时newPt和pt完全相同 地址都是0Xaaaa  内容为0X1111  即newPt只是pt的别名，对任何一个操作就等于对另一个操作。 因此retainCount不需要增加。<br>retain的情况：NSString <em>newPt = [pt retain];<br>此时newPt的地址不再为0Xaaaa，可能为0Xaabb 但是内容依然为0X1111。 因此newPt 和 pt 都可以管理”abc”所在的内存。因此 retainCount需要增加1<br>copy的情况：NSString </em>newPt = [pt copy];<br>此时会在堆上重新开辟一段内存存放@”abc” 比如0X1122 内容为@”abc 同时会在栈上为newPt分配空间 比如地址：0Xaacc 内容为0X1122 因此retainCount增加1供newPt来管理0X1122这段内存</p>
<p>//——————————————————————————<br>看了这么多也许大家有点晕， 现在进行实际的代码演示：<br>@property (nonatomic, assign) int number;<br>这里定义了一个int类型的属性， 那么这个int是简单数据类型，本身可以认为就是原子访问，所以用nonatomic,  不需要进行引用计数，所以用assign。 适用于所有简单数据类型。<br>@property (nonatomic, copy) NSString <em> myString;<br>这里定义了一个NSString类型的属性，不需要原子操作，所以用nonatomic.<br>为什么需要copy，而不是retain呢！ 因为如果对myString赋值原字符串是一个可变的字符串(NSMutableString)对象的话，用retain的话，当原字符串改变的时候你的myString属性也会跟着变掉。我想你不希望看到这个现象。 实际上博主测试， 如果原来的字符串是NSString的话，也只是retain一下，并不会copy副本<br>@property (nonatomic, retain) UIView </em> myView;<br>这里定义了一个UIView类型的属性，不需要原子操作，所以用nonatomic.<br>当对myView 赋值的时候原来的UIView对象retainCount会加1<br>//接口文件<br>@interface MyClass : NSObject<br>@property (nonatomic, assign)   int              number;<br>@property (nonatomic, copy)   NSString  <em> myString;<br>@property (nonatomic, retain) UIView    </em> myView;<br>@end<br>//实现文件<br>@implementation MyClass<br>@synthesize number;<br>@synthesize myString;<br>@synthesize myView;<br>//释放内存<br>-(void) dealloc<br>{<br>[myString release];  //copy的属性需要release;<br>[myView release];    //retain的属性需要release;<br>[super dealloc]; //传回父对象<br>}<br>@end<br>假如你有一段代码创建了一个MyClass对象<br>MyClass <em> instance  = [MyClass alloc] init];<br>//number赋值，没什么可说的， 简单数据类型就这样<br>instance.number = 1;<br>//创建一个可变字符串<br>NSMutableString </em> string = [NSMutableString stringWithString:@”hello”];<br>instance.myString = string;                   //对myString赋值<br>[string appendString:@” world!”];      //往string追加文本<br>NSLog(@”%@”,string);                        //此处string已经改变， 输出为 “hello world!”<br>NSLog(@”%@”,instance.myString);   //输出myString，你会发现此处输出仍然为 “hello” 因为 myString在string改变之前已经copy了一份副本<br>UIView * view = [[UIView alloc] init];<br>NSLog(@”retainCount = %d”,view.retainCount);<br>//输出view的引用计数， 此时为1<br>instance.myView = view; //对myView属性赋值<br>NSLog(@”retainCount = %d”,view.retainCount);<br>//再次输出view的引用计数， 此时为2，因为myView对view进行了一次retain。<br>[view release];<br>//此处虽然view被release释放掉了，但myView对view进行了一次retain，那么myView保留的UIView的对象指针仍然有效。<br>[instance release] ;</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/07/15/nonatomic、-synthesize、-property、-dynamic/">
    <time datetime="2014-07-15T04:40:38.000Z" class="entry-date">
        2014-07-15
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
</article>






  
  

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2016/02/13/ios-xmpp协议/">ios-xmpp协议</a>
          </li>
        
          <li>
            <a href="/2015/11/17/ios-加密方式/">ios-加密方式</a>
          </li>
        
          <li>
            <a href="/2015/06/23/ios-Runtime机制/">ios-Runtime机制</a>
          </li>
        
          <li>
            <a href="/2015/06/16/ios页面跳转机制/">ios页面跳转机制</a>
          </li>
        
          <li>
            <a href="/2014/10/15/store流程/">store流程</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2016 小俊
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>