<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="LJ" />
  

  
  
  
  
  
  
  <title>关键字介绍：nonatomic、@synthesize、@property、@dynamic | 孤狼的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1.#synthesize关键字: 根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量 。
2.@implementation 关键字，表明类的实现 @end 结束
3.self 关键字 ：类似于java中的this，是隐藏参数，指向当前调用方法的类。
super 关键字 ：调用父类的方法。
self = [superinit]  这里不是判断">
<meta property="og:type" content="article">
<meta property="og:title" content="关键字介绍：nonatomic、@synthesize、@property、@dynamic">
<meta property="og:url" content="http://yoursite.com/2014/07/15/nonatomic、-synthesize、-property、-dynamic/index.html">
<meta property="og:site_name" content="孤狼的技术博客">
<meta property="og:description" content="1.#synthesize关键字: 根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量 。
2.@implementation 关键字，表明类的实现 @end 结束
3.self 关键字 ：类似于java中的this，是隐藏参数，指向当前调用方法的类。
super 关键字 ：调用父类的方法。
self = [superinit]  这里不是判断">
<meta property="og:updated_time" content="2016-06-15T04:46:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关键字介绍：nonatomic、@synthesize、@property、@dynamic">
<meta name="twitter:description" content="1.#synthesize关键字: 根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量 。
2.@implementation 关键字，表明类的实现 @end 结束
3.self 关键字 ：类似于java中的this，是隐藏参数，指向当前调用方法的类。
super 关键字 ：调用父类的方法。
self = [superinit]  这里不是判断">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="孤狼的技术博客" rel="home">孤狼的技术博客</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">西伯利亚的嗜血狼王</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="ios-nonatomic、-synthesize、-property、-dynamic" class="ios-nonatomic、-synthesize、-property、-dynamic post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      关键字介绍：nonatomic、@synthesize、@property、@dynamic
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2014/07/15/nonatomic、-synthesize、-property、-dynamic/" data-id="ciq0acduq00088as6mx6tabhi" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>1.#synthesize关键字: 根据@property设置，自动生成成员变量相应的存取方法，从而可以使用点操作符来方便的存取该成员变量 。</p>
<p>2.@implementation 关键字，表明类的实现 @end 结束</p>
<p>3.self 关键字 ：类似于java中的this，是隐藏参数，指向当前调用方法的类。</p>
<p>super 关键字 ：调用父类的方法。</p>
<p>self = [superinit]  这里不是判断self与[superinit]是否相等，而是判断是否可以成功初始化。[super init]：父类初始化成功的话，通过=给self，这样self成为一个非空对象，整个来说即非false(非NO)。</p>
<p>#import 告诉预处理器,将头文件的内容包含到本文件中. OC 中的import 能保证头文件只会被包含一次 .@interface关键字：声明一个Student类。@end 结束声明.</p>
<p>冒号:表示继承 后面跟的是父类.  </p>
<p>NSObject是大多数对象都会用到的内存管理,和初始化框架,以及反射和类型操作. 相 当于Object。</p>
<p>NS是NextSTEP缩写,表示这个函数来自Cocoa工具包。</p>
<p>声明全局变量 , 与C中一样。</p>
<p>property关键字：设置成员变量的属性（有读／写，赋值assign,retain,copy ,以及对多线程的支持nonatomic）。</p>
<p>声明一个方法，格式是  –(返回值) 方法关键字1 : (参数类型)参数名 方法关键字2 : (参数类型)参数名 …… （在读方法的时候就可以先找方法关键字来确定参数）。</p>
<ul>
<li>减号是实例方法， + 是类方法</li>
</ul>
<ol>
<li><p>另一个初始化方法中调用已有的初始化方法  这种概念被称为Designated Initializer.</p>
</li>
<li><p>NSLog是OC中的标准输出, 附加输出当时日期, 时间, 应用程序名称 . 使用NSLog()输出任意对象的值时,都会使用%@格式说明。在使用这个说明符时,对象通过一个名为description的方法提供自己的NSLog()格式。 </p>
</li>
</ol>
<p>使用@property配合@synthesize可以让编译器自动实现getter/setter方法，使用的时候也很方便，可以直接使用“对象.属性”的方法调用;如果我们想要”对象.方法“的方式来调用一个方法并获取到方法的返回值，那就需要使用@property配合@dynamic了</p>
<p>使用@dynamic关键字是告诉编译器由我们自己来实现访问方法。如果使用的是@synthesize，那么这个工作编译器就会帮你实现了。</p>
<p>readonly此标记说明属性是只读的，默认的标记是读写，如果你指定了只读，在@implementation中只需要一个读取器。或者如果你使用@synthesize关键字，也是有读取器方法被解析。而且如果你试图使用点操作符为属性赋值，你将得到一个编译错误。</p>
<p>readwrite此标记说明属性会被当成读写的，这也是默认属性。设置器和读取器都需要在@implementation中实现。如果使用@synthesize关键字，读取器和设置器都会被解析。</p>
<p>nonatomic：非原子性访问，对属性赋值的时候不加锁，多线程并发访问会提高性能。如果不加此属性，则默认是两个访问方法都为原子型事务访问。<br>atomic和nonatomic用来决定编译器生成的getter和setter是否为原子操作。<br>atomic<br>设置成员变量的@property属性时，默认为atomic，提供多线程安全。<br>在多线程环境下，原子操作是必要的，否则有可能引起错误的结果。加了atomic，setter函数会变成下面这样：<br>{lock}<br>if (property != newValue) {<br>[property release];<br>property = [newValue retain];<br>}<br>{unlock}<br>nonatomic<br>禁止多线程，变量保护，提高性能。<br>atomic是Objc使用的一种线程保护技术，基本上来讲，是防止在写未完成的时候被另外一个线程读取，造成数据错误。而这种机制是耗费系统资源的，所以在iPhone这种小型设备上，如果没有使用多线程间的通讯编程，那么nonatomic是一个非常好的选择。<br>指出访问器不是原子操作，而默认地，访问器是原子操作。这也就是说，在多线程环境下，解析的访问器提供一个对属性的安全访问，从获取器得到的返回值或者通过设置器设置的值可以一次完成，即便是别的线程也正在对其进行访问。如果你不指定 nonatomic ，在自己管理内存的环境中，解析的访问器保留并自动释放返回的值，如果指定了 nonatomic ，那么访问器只是简单地返回这个值。<br>assign: 简单赋值，不更改索引计数<br>对基础数据类型 （例如NSInteger，CGFloat）和C数据类型（int, float, double, char, 等）       适用简单数据类型<br>此标记说明设置器直接进行赋值，这也是默认值。在使用垃圾收集的应用程序中，如果你要一个属性使用assign，且这个类符合NSCopying协             议，你就要明确指出这个标记，而不是简单地使用默认值，否则的话，你将得到一个编译警告。这再次向编译器说明你确实需要赋值，即使它是           可拷贝的。<br>copy:建立一个索引计数为1的对象，然后释放旧对象                对NSString<br>对NSString 它指出，在赋值时使用传入值的一份拷贝。拷贝工作由copy方法执行，此属性只对那些实行了NSCopying协议的对象类型有效。更深入的讨论，请参考“复制”部分。<br>retain:释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1<br>对其他NSObject和其子类<br>对参数进行release旧值，再retain新值<br>指定retain会在赋值时唤醒传入值的retain消息。此属性只能用于Objective-C对象类型，而不能用于Core Foundation对象。(原因很明显，retain会增加对象的引用计数，而基本数据类型或者Core Foundation对象都没有引用计数——译者注)。<br>注意: 把对象添加到数组中时，引用计数将增加对象的引用次数+1。<br>retain的实际语法为：</p>
<ul>
<li>(void)setName:(NSString *)newName {<br>if (name != newName) {<br>[name release];<br>name = [newName retain];<br>// name’s retain count has been bumped up by 1<br>}<br>}<br>copy与retain：<br>Copy其实是建立了一个相同的对象，而retain不是：<br>比如一个NSString对象，地址为0×1111，内容为@”STR”<br>Copy到另外一个NSString之后，地址为0×2222，内容相同，新的对象retain为1，旧有对象没有变化<br>retain到另外一个NSString之后，地址相同（建立一个指针，指针拷贝），内容当然相同，这个对象的retain值+1<br>也就是说，retain是指针拷贝，copy是内容拷贝。哇，比想象的简单多了…</li>
</ul>
<p>retain的set方法应该是浅复制，copy的set方法应该是深复制了<br>copy另一个用法：<br>copy是内容的拷贝  ,对于像NSString,的确是这样.<br>但是,如果是copy的是一个NSArray呢?比如,<br>NSArray <em>array = [NSArray arrayWithObjects:@”hello”,@”world”,@”baby”];<br>NSArray </em>array2 = [array copy];<br>这个时候,,系统的确是为array2开辟了一块内存空间,但是我们要认识到的是,array2中的每个元素,,只是copy了指向array中相对应元素的指针.这便是所谓的”浅复制”.<br>assign与retain：</p>
<ol>
<li>接触过C，那么假设你用malloc分配了一块内存，并且把它的地址赋值给了指针a，后来你希望指针b也共享这块内存，于是你又把a赋值给（assign）了b。此时a和b指向同一块内存，请问当a不再需要这块内存，能否直接释放它？答案是否定的，因为a并不知道b是否还在使用这块内存，如果a释放了，那么b在使用这块内存的时候会引起程序crash掉。</li>
<li>了解到1中assign的问题，那么如何解决？最简单的一个方法就是使用引用计数（reference counting），还是上面的那个例子，我们给那块内存设一个引用计数，当内存被分配并且赋值给a时，引用计数是1。当把a赋值给b时引用计数增加到2。这时如果a不再使用这块内存，它只需要把引用计数减1，表明自己不再拥有这块内存。b不再使用这块内存时也把引用计数减1。当引用计数变为0的时候，代表该内存不再被任何指针所引用，系统可以把它直接释放掉。<br>总结：上面两点其实就是assign和retain的区别，assign就是直接赋值，从而可能引起1中的问题，当数据为int, float等原生类型时，可以使用assign。retain就如2中所述，使用了引用计数，retain引起引用计数加1, release引起引用计数减1，当引用计数为0时，dealloc函数被调用，内存被回收。</li>
</ol>
<p>NSString <em>pt = [[NSString alloc] initWithString:@”abc”];<br>上面一段代码会执行以下两个动作<br>1 在堆上分配一段内存用来存储@”abc”  比如：内存地址为：0X1111 内容为 “abc”<br>2 在栈上分配一段内存用来存储pt  比如：地址为：0Xaaaa 内容自然为0X1111<br>下面分别看下assign retain copy<br>assign的情况：NSString </em>newPt = [pt assing];<br>此时newPt和pt完全相同 地址都是0Xaaaa  内容为0X1111  即newPt只是pt的别名，对任何一个操作就等于对另一个操作。 因此retainCount不需要增加。<br>retain的情况：NSString <em>newPt = [pt retain];<br>此时newPt的地址不再为0Xaaaa，可能为0Xaabb 但是内容依然为0X1111。 因此newPt 和 pt 都可以管理”abc”所在的内存。因此 retainCount需要增加1<br>copy的情况：NSString </em>newPt = [pt copy];<br>此时会在堆上重新开辟一段内存存放@”abc” 比如0X1122 内容为@”abc 同时会在栈上为newPt分配空间 比如地址：0Xaacc 内容为0X1122 因此retainCount增加1供newPt来管理0X1122这段内存</p>
<p>//——————————————————————————<br>看了这么多也许大家有点晕， 现在进行实际的代码演示：<br>@property (nonatomic, assign) int number;<br>这里定义了一个int类型的属性， 那么这个int是简单数据类型，本身可以认为就是原子访问，所以用nonatomic,  不需要进行引用计数，所以用assign。 适用于所有简单数据类型。<br>@property (nonatomic, copy) NSString <em> myString;<br>这里定义了一个NSString类型的属性，不需要原子操作，所以用nonatomic.<br>为什么需要copy，而不是retain呢！ 因为如果对myString赋值原字符串是一个可变的字符串(NSMutableString)对象的话，用retain的话，当原字符串改变的时候你的myString属性也会跟着变掉。我想你不希望看到这个现象。 实际上博主测试， 如果原来的字符串是NSString的话，也只是retain一下，并不会copy副本<br>@property (nonatomic, retain) UIView </em> myView;<br>这里定义了一个UIView类型的属性，不需要原子操作，所以用nonatomic.<br>当对myView 赋值的时候原来的UIView对象retainCount会加1<br>//接口文件<br>@interface MyClass : NSObject<br>@property (nonatomic, assign)   int              number;<br>@property (nonatomic, copy)   NSString  <em> myString;<br>@property (nonatomic, retain) UIView    </em> myView;<br>@end<br>//实现文件<br>@implementation MyClass<br>@synthesize number;<br>@synthesize myString;<br>@synthesize myView;<br>//释放内存<br>-(void) dealloc<br>{<br>[myString release];  //copy的属性需要release;<br>[myView release];    //retain的属性需要release;<br>[super dealloc]; //传回父对象<br>}<br>@end<br>假如你有一段代码创建了一个MyClass对象<br>MyClass <em> instance  = [MyClass alloc] init];<br>//number赋值，没什么可说的， 简单数据类型就这样<br>instance.number = 1;<br>//创建一个可变字符串<br>NSMutableString </em> string = [NSMutableString stringWithString:@”hello”];<br>instance.myString = string;                   //对myString赋值<br>[string appendString:@” world!”];      //往string追加文本<br>NSLog(@”%@”,string);                        //此处string已经改变， 输出为 “hello world!”<br>NSLog(@”%@”,instance.myString);   //输出myString，你会发现此处输出仍然为 “hello” 因为 myString在string改变之前已经copy了一份副本<br>UIView * view = [[UIView alloc] init];<br>NSLog(@”retainCount = %d”,view.retainCount);<br>//输出view的引用计数， 此时为1<br>instance.myView = view; //对myView属性赋值<br>NSLog(@”retainCount = %d”,view.retainCount);<br>//再次输出view的引用计数， 此时为2，因为myView对view进行了一次retain。<br>[view release];<br>//此处虽然view被release释放掉了，但myView对view进行了一次retain，那么myView保留的UIView的对象指针仍然有效。<br>[instance release] ;</p>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2014/07/15/nonatomic、-synthesize、-property、-dynamic/">
    <time datetime="2014-07-15T04:40:38.000Z" class="entry-date">
        2014-07-15
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2014/10/15/store流程/" rel="prev"><span class="meta-nav">←</span> store流程</a></span>
    
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2016/02/13/ios-xmpp协议/">ios-xmpp协议</a>
          </li>
        
          <li>
            <a href="/2015/11/17/ios-加密方式/">ios-加密方式</a>
          </li>
        
          <li>
            <a href="/2015/06/23/ios-Runtime机制/">ios-Runtime机制</a>
          </li>
        
          <li>
            <a href="/2015/06/16/ios页面跳转机制/">ios页面跳转机制</a>
          </li>
        
          <li>
            <a href="/2014/10/15/store流程/">store流程</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2016 小俊
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>