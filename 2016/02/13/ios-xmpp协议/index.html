<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="LJ" />
  

  
  
  
  
  
  
  <title>ios-xmpp协议 | 孤狼的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="什么是OpenFireOpenfire 采用Java开发，开源的实时协作（RTC）服务器基于XMPP（Jabber）协议。　　您可以使用它轻易的构建高效率的即时通信服务器。Openfire安装和使用都非常简单，并利用Web进行管理。单台服务器可支持上万并发用户。
由于是采用开放的XMPP协议，您可以使用各种支持XMPP协议的IM客户端软件登陆服务。XMPP（Jabber）协议
1、 介绍XMPP">
<meta property="og:type" content="article">
<meta property="og:title" content="ios-xmpp协议">
<meta property="og:url" content="http://yoursite.com/2016/02/13/ios-xmpp协议/index.html">
<meta property="og:site_name" content="孤狼的技术博客">
<meta property="og:description" content="什么是OpenFireOpenfire 采用Java开发，开源的实时协作（RTC）服务器基于XMPP（Jabber）协议。　　您可以使用它轻易的构建高效率的即时通信服务器。Openfire安装和使用都非常简单，并利用Web进行管理。单台服务器可支持上万并发用户。
由于是采用开放的XMPP协议，您可以使用各种支持XMPP协议的IM客户端软件登陆服务。XMPP（Jabber）协议
1、 介绍XMPP">
<meta property="og:updated_time" content="2016-06-13T13:39:08.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ios-xmpp协议">
<meta name="twitter:description" content="什么是OpenFireOpenfire 采用Java开发，开源的实时协作（RTC）服务器基于XMPP（Jabber）协议。　　您可以使用它轻易的构建高效率的即时通信服务器。Openfire安装和使用都非常简单，并利用Web进行管理。单台服务器可支持上万并发用户。
由于是采用开放的XMPP协议，您可以使用各种支持XMPP协议的IM客户端软件登陆服务。XMPP（Jabber）协议
1、 介绍XMPP">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="孤狼的技术博客" rel="home">孤狼的技术博客</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">西伯利亚的嗜血狼王</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-ios-xmpp协议" class="post-ios-xmpp协议 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      ios-xmpp协议
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2016/02/13/ios-xmpp协议/" data-id="cipj9appq0007ens6lpzs123e" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p><span></span></p>
<p>什么是OpenFire<br>Openfire 采用Java开发，开源的实时协作（RTC）服务器基于XMPP（Jabber）协议。<br>　　您可以使用它轻易的构建高效率的即时通信服务器。Openfire安装和使用都非常简单，并利用Web进行管理。单台服务器可支持上万并发用户。</p>
<p>由于是采用开放的XMPP协议，您可以使用各种支持XMPP协议的IM客户端软件登陆服务。<br>XMPP（Jabber）协议</p>
<p>1、 介绍<br>XMPP是一种基于XML的协议，它继承了在XML环境中灵活的发展性。因此，基于XMPP的应用具有超强的可扩展性。经过扩展以后的XMPP可以通过发送扩展的信息来处理用户的需求，以及在XMPP的顶端建立如内容发布系统和基于地址的服务等应用程 序。而且，XMPP包含了针对服务器端的软件协议，使之能与另一个进行通话，这使得开发者更容易建立客户应用程序或给一个配好系统添加功能。</p>
<p>2、 定义：<br>XMPP（可扩展消息处理现场协议）是基于可扩展标记语言（XML）的协议，它用于即时消息（IM）以及在线现场探测。它在促进服务器之间的准即时操作。这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息，即使其操作系统和浏览器不同。<br>XMPP的前身是Jabber， 一个开源形式组织产生的网络即时通信协议。XMPP目前被IETF国际标准组织完成了标准化工作。标准化的核心结果分为两部分；</p>
<p>核心的XML流传输协议<br>基于XML FreeEIM流传输的即时通讯扩展应用<br>XMPP的核心XML流传输协议的定义使得XMPP能够在一个比以往网络通信协议更规范的平台上。借助于XML易于解析和阅读的特性，使得XMPP的协议能够非常漂亮。<br>XMPP的即时通讯扩展应用部分是根据IETF在这之前对即时通讯的一个抽象定义的，与其他业已得到广泛使用的即时通讯协议，诸如AIM，QQ等有功能完整，完善等先进性。<br>在IETF 中，把IM协议划分为四种协议，即时信息和出席协议(Instant Messaging and Presence Protocol, IMPP)、出席和即时信息协议(Presence and Instant Messaging Protocol, PRIM)、针对即时信息和出席扩展的会话发起协议(Session Initiation Protocol for Instant Messaging and Presence Leveraging Extensions, SIMPLE)，以及可扩展的消息出席协议(XMPP)。最初研发IMPP 也是为了创建一种标准化的协议，但是今天，IMPP 已经发展成为基本协议单元，定义所有即时通信协议应该支持的核心功能集。</p>
<p>3、 XMPP协议的优点<br>a. XMPP 协议是公开的，由JSF开源社区组织开发的。XMPP 协议并不属于任何的机构和个人，而是属于整个社区，这一点从根本上保证了其开放性。</p>
<p>b. XMPP 协议具有良好的扩展性。在XMPP 中，即时消息和到场信息都是基于XML 的结构化信息，这些信息以XML 节(XML Stanza)的形式在通信实体间交换。XMPP 发挥了XML 结构化数据的通用传输层的作用，它将出席和上下文敏感信息嵌入到XML 结构化数据中，从而使数据以极高的效率传送给最合适的资源。基于XML 建立起来的应用具有良好的语义完整性和扩展性。</p>
<p>c. 分布式的网络架构。XMPP 协议都是基于Client/Server 架构，但是XMPP协议本身并没有这样的限制。网络的架构和电子邮件十分相似，但没有结合任何特定的网络架构，适用范围非常广泛。</p>
<p>d. XMPP 具有很好的弹性。XMPP 除了可用在即时通信的应用程序，还能用在网络管理、内容供稿、协同工具、档案共享、游戏、远端系统监控等。</p>
<p>e. 安全性。XMPP在Client-to-Server通信，和Server-to-Server通信中都使用TLS (Transport Layer Security)协议作为通信通道的加密方法，保证通信的安全。任何XMPP服务器可以独立于公众XMPP网络（例如在企业内部网络中），而使用SASL及TLS等技术更加增强了通信的安全性。如下图所示：</p>
<p>4、 XMPP协议的组成<br>主要的XMPP 协议范本及当今应用很广的XMPP 扩展：<br>l RFC 3920 XMPP（新的RFC6120）：核心。定义了XMPP 协议框架下应用的网络架构，引入了XML Stream（XML 流）与XML Stanza（XML 节），并规定XMPP 协议在通信过程中使用的XML 标签。使用XML 标签从根本上说是协议开放性与扩展性的需要。此外，在通信的安全方面，把TLS 安全传输机制与SASL 认证机制引入到内核，与XMPP 进行无缝的连接，为协议的安全性、可靠性奠定了基础。Core 文档还规定了错误的定义及处理、XML 的使用规范、JID（Jabber Identifier，Jabber 标识符）的定义、命名规范等等。所以这是所有基于XMPP 协议的应用都必需支持的文档。</p>
<p>l RFC 3921：用户成功登陆到服务器之后，发布更新自己的在线好友管理、发送即时聊天消息等业务。所有的这些业务都是通过三种基本的XML 节来完成的：IQ Stanza（IQ 节）, Presence Stanza（Presence 节）, Message Stanza（Message 节）。RFC3921 还对阻塞策略进行了定义，定义是多种阻塞方式。可以说，RFC3921 是RFC3920 的充分补充。两个文档结合起来，就形成了一个基本的即时通信协议平台，在这个平台上可以开发出各种各样的应用。</p>
<p>l XEP-0030 服务搜索。一个强大的用来测定XMPP 网络中的其它实体所支持特性的协议。<br>l XEP-0115 实体性能。XEP-0030 的一个通过即时出席的定制，可以实时改变交变广告功能。<br>l XEP-0045 多人聊天。一组定义参与和管理多用户聊天室的协议，类似于Internet 的Relay Chat，具有很高的安全性。<br>l XEP-0096 文件传输。定义了从一个XMPP 实体到另一个的文件传输。<br>l XEP-0124 HTTP 绑定。将XMPP 绑定到HTTP 而不是TCP，主要用于不能够持久的维持与服务器TCP 连接的设备。<br>l XEP-0166 Jingle。规定了多媒体通信协商的整体架构。<br>l XEP-0167 Jingle Audio Content Description Format。定义了从一个XMPP 实体到另一个的语音传输过程。<br>l XEP-0176 Jingle ICE（Interactive Connectivity Establishment）Transport。ICE传输机制，文件解决了如何让防火墙或是NAT（Network Address Translation）保护下的实体建立连接的问题。<br>l XEP-0177 Jingle Raw UDP Transport。纯UDP 传输机制，文件讲述了如何在没有防火墙且在同一网络下建立连接的。<br>l XEP-0180 Jingle Video Content Description Format。定义了从一个XMPP 实体到另一个的视频传输过程。<br>l XEP-0181 Jingle DTMF（Dual Tone Multi-Frequency）。<br>l XEP-0183 Jingle Telepathy Transport Method。</p>
<p>5、 XMPP协议网络架构</p>
<p>XMPP是一个典型的C/S架构，而不是像大多数即时通讯软件一样，使用P2P客户端到客户端的架构，也就是说在大多数情况下，当两个客户端进行通讯时，他们的消息都是通过服务器传递的(也有例外，例如在两个客户端传输文件时)．采用这种架构，主要是为了简化客户端，将大多数工作放在服务器端进行，这样，客户端的工作就比较简单，而且，当增加功能时，多数是在服务器端进行．XMPP服务的框架结构如下图所示．XMPP中定义了三个角色，XMPP客户端，XMPP服务器、网关．通信能够在这三者的任意两个之间双向发生．服务器同时承担了客户端信息记录、连接管理和信息的路由功能．网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS(短信)、MSN、ICQ等．基本的网络形式是单客户端通过TCP／IP连接到单服务器，然后在之上传输XML，工作原理是：<br>(1) 点连接到服务器；<br>(2) 务器利用本地目录系统中的证书对其认证；<br>(3) 点指定目标地址，让服务器告知目标状态；<br>(4) 务器查找、连接并进行相互认证；<br>(5) 点之间进行交互；</p>
<p>6、 XMPP客户端<br>XMPP 系统的一个设计标准是必须支持简单的客户端。事实上，XMPP 系统架构对客户端只有很少的几个限制。一个XMPP 客户端必须支持的功能有：</p>
<ol>
<li>通过 TCP 套接字与XMPP 服务器进行通信；</li>
<li>解析组织好的 XML 信息包；</li>
<li>理解消息数据类型。</li>
</ol>
<p>XMPP 将复杂性从客户端转移到服务器端。这使得客户端编写变得非常容易，更新系统功能也同样变得容易。XMPP 客户端与服务端通过XML 在TCP 套接字的5222 端口进行通信，而不需要客户端之间直接进行通信。<br>基本的XMPP 客户端必须实现以下标准协议（XEP-0211）：<br>RFC3920 核心协议Core<br>RFC3921 即时消息和出席协议Instant Messaging and Presence<br>XEP-0030 服务发现Service Discovery<br>XEP-0115 实体能力Entity Capabilities</p>
<p>7、 XMPP服务器<br>XMPP 服务器遵循两个主要法则：<br>1、监听客户端连接，并直接与客户端应用程序通信；<br>2、与其他 XMPP 服务器通信；</p>
<p>XMPP开源服务器一般被设计成模块化，由各个不同的代码包构成，这些代码包分别处理Session管理、用户和服务器之间的通信、服务器之间的通信、DNS（Domain Name System）转换、存储用户的个人信息和朋友名单、保留用户在下线时收到的信息、用户注册、用户的身份和权限认证、根据用户的要求过滤信息和系统记录等。另外，服务器可以通过附加服务来进行扩展，如完整的安全策略，允许服务器组件的连接或客户端选择，通向其他消息系统的网关。<br>基本的XMPP 服务器必须实现以下标准协议<br>RFC3920 核心协议Core<br>RFC3921 即时消息和出席协议Instant Messaging and Presence<br>XEP-0030 服务发现Service Discovery</p>
<p>8、 XMPP网关</p>
<p>XMPP 突出的特点是可以和其他即时通信系统交换信息和用户在线状况。由于协议不同，XMPP 和其他系统交换信息必须通过协议的转换来实现，目前几种主流即时通信协议都没有公开，所以XMPP 服务器本身并没有实现和其他协议的转换，但它的架构允许转换的实现。实现这个特殊功能的服务端在XMPP 架构里叫做网关(gateway)。目前，XMPP 实现了和AIM、ICQ、IRC、MSN Massager、RSS0.9 和Yahoo Massager 的协议转换。由于网关的存在，XMPP 架构事实上兼容所有其他即时通信网络，这无疑大大提高了XMPP 的灵活性和可扩展性。</p>
<p>9、 XMPP地址格式</p>
<p>一个实体在XMPP网络结构中被称为一个接点，它有唯一的标示符jabber identifier(JID)，即实体地址，用来表示一个Jabber用户，但是也可以表示其他内容，例如一个聊天室．一个有效的JID包括一系列元素：<br>(1) 名(domain identifier)；<br>(2) 点(node identifier)；<br>(3) 源(resource identifier)．</p>
<p>它的格式是node@domain/resource，node@domain，类似电子邮件的地址格式．domain用来表示接点不同的设备或位置，这个是可选的，例如a在Server1上注册了一个用户，用户名为doom，那么a的JID就是doom@serverl，在发送消息时，指明doom@serverl就可以了，resource可以不用指定，但a在登录到这个Server时，fl的JID可能是doom@serverl、exodus(如果a用Exodus软件登录)，也可能是[email=doom@serverl/psi]doom@serverl/psi<a href="如果a用psi软件登录">/email</a>．资源只用来识别属于用户的位置或设备等，一个用户可以同时以多种资源与同一个XMPP服务器连接。</p>
<p>10、 XMPP消息格式</p>
<p>XMPP中定义了3个顶层XML元素: Message、Presence、IQ，下面针对这三种元素进行介绍。</p>
<p><message><br>用于在两个jabber用户之间发送信息。Jsm(jabber会话管理器)负责满足所有的消息，不管目标用户的状态如何。如果用户在线jsm立即提交;否则jsm就存储。<br>To : 标识消息的接收方。<br>from : 指发送方的名字或标示(id)<br>Text: 此元素包含了要提交给目标用户的信息。</message></p>
<p>结构如下所示:</p>
<p><message to="‘lily@jabber.org/contact’" type="’chat’"></message></p>
<p><body> 你好，在忙吗</body><br></p>
<p><presence><br>用来表明用户的状态，如：online、away、dnd(请勿打扰)等。当用户离线或改变自己的状态时，就会在stream的上下文中插入一个Presence元素，来表明自身的状态．结构如下所示：</presence></p>
<p><presence><br>From =‘lily @ jabber.com/contact’<br>To = ‘yaoman @ jabber.com/contact’</presence></p>
<p><status> Online </status><br></p>
<p><presence>元素可以取下面几种值:<br>Probe: 用于向接受消息方法发送特殊的请求<br>subscribe: 当接受方状态改变时，自动向发送方发送presence信息。<br>&lt; IQ &gt;</presence></p>
<p>一种请求／响应机制，从一个实体从发送请求，另外一个实体接受请求，并进行响应．例如，client在stream的上下文中插入一个元素，向Server请求得到自己的好友列表，Server返回一个，里面是请求的结果．</p>
<p><iq> 主要的属性是type。包括:<br>Get :获取当前域值。<br>Set :设置或替换get查询的值。<br>Result :说明成功的响应了先前的查询。<br>Error: 查询和响应中出现的错误。</iq></p>
<p>结构如下所示:</p>
<p><iq from="‘lily" @="" jabber.com="" contact’id="’1364564666’" type="’result’"><br>XMPP通信协议</iq></p>
<p>一、 Stream<br><!-- #################### 通信内容采用压缩技术，以及通信的相关协议 ####################### --></p>
<p><stream:stream xmlns:stream="http://etherx.jabber.org/streams" xmlns="jabber:client" from="127.0.0.1" id="e38900bc" xml:lang="en" version="1.0"><br><!--
 xmlns 表示通信客户端
 from 客户端的地址（来源）
 id
 lang 通信语言
 -->        </stream:stream></p>
<p><stream:features><br><!-- 开始tls协议[TLS]的频道加密方法 --></stream:features></p>
<p><starttls xmlns="urn:ietf:params:xml:ns:xmpp-tls"></starttls><br><!-- 加密技术、安全证书 --></p>
<p><mechanisms xmlns="urn:ietf:params:xml:ns:xmpp-sasl"></mechanisms></p>
<p><mechanism>DIGEST-MD5</mechanism></p>
<p><mechanism>PLAIN</mechanism></p>
<p><mechanism>ANONYMOUS</mechanism></p>
<p><mechanism>CRAM-MD5</mechanism><br><br><!-- 采用压缩技术 --></p>
<p><compression xmlns="http://jabber.org/features/compress"></compression></p>
<p><method>zlib</method><br><br><!-- 权限 --></p>
<p><auth xmlns="http://jabber.org/features/iq-auth"><br><!-- 注册 --></auth></p>
<p><register xmlns="http://jabber.org/features/iq-register"><br></register></p>
<p>关于TSL 参考：<a href="http://www.jabbercn.org/RFC3920" target="_blank" rel="external">http://www.jabbercn.org/RFC3920</a><br>1、TSL协议遵循以下规则：<br>A、 一个遵守本协议的初始化实体必须（MUST）在初始化流的头信息中包含一个’version’属性并把值设为“1.0”。<br>B、 如果TLS握手发生在两个服务器之间，除非服务器声称的DNS主机名已经被解析，通信不能（MUST NOT）继续进行。<br>C、 当一个遵守本协议的接收实体接收了一个初始化流（它的头信息中包含一个’version’属性并且值设为“1.0”），在发送应答流的的头信息（其中包含版本标记）之后，它必须发送（MUST）<starttls>元素（名字空间为 ‘urn:ietf:params:xml:ns:xmpp-tls’）以及其他它支持的流特性。<br>D、 如果初始化实体选择使用TLS,TLS握手必须在SASL握手之前完成；这个顺序用于帮助保护SASL握手时发送的认证信息的安全，同时可以在必要的时候在TLS握手之前为SASL外部机制提供证书。<br>E、 TLS握手期间,一个实体不能（MUST NOT）在流的根元素中发送任何空格符号作为元素的分隔符（在下面的TLS示例中的任何空格符都仅仅是为了便于阅读）；这个禁令用来帮助确保安全层字节精度。<br>F、 接收实体必须（MUST）在发送<proceed> 元素的关闭符号”&gt;” 之后立刻开始TLS协商。初始化实体必须（MUST）在从接收实体接收到<proceed> 元素的关闭符号”&gt;” 之后立刻开始TLS协商。<br>G、 初始化实体必须（MUST）验证接收实体出示的证书；关于证书验证流程参见Certificate Validation ( 第十四章第二节)。<br>H、 证书必须（MUST）检查初始化实体(比如一个用户)提供的主机名；而不是通过DNS系统解析出来的主机名；例如，如果用户指定一个主机名”example.com”而一个DNS SRV [SRV]查询返回”im.example.com”，证书必须（MUST）检查”example.com”.如果任何种类的XMPP实体（例如客户端或服务器）的JID出现在一个证书里，它必须（MUST）表现为一个别名实体里面的UTF8字符串，存在于subjectAltName之中。如何使用 [ASN.1] 对象标识符 “id-on-xmppAddr” 定义在本文的第五章第一节第一小节。<br>I、 如果 TLS 握手成功了，接收实体必须（MUST） 丢弃TLS 生效之前从初始化实体得到的任何不可靠的信息<br>J、 如果 TLS 握手成功了，初始化实体必须（MUST） 丢弃TLS 生效之前从接收实体得到的任何不可靠的信息<br>K、 如果 TLS 握手成功了，接收实体不能(MUST NOT)在流重新开始的时候通过提供其他的流特性来向初始化实体提供 STARTTLS 扩展<br>L、 如果 TLS 握手成功了，初始化实体必须(MUST)继续进行SASL握手<br>M、 如果 TLS 握手失败了，接收实体必须（MUST）终止XML流和相应的TCP连接。<br>N、 关于必须（MUST）支持的机制，参照 Mandatory-to-Implement Technologies (第十四章第七节) 。<br>2、当一个初始化实体用TLS保护一个和接收实体之间的流，其步骤如下:<br>A. 初始化实体打开一个TCP连接，发送一个打开的XML流头信息（其’version’属性设置为”1.0”）给接收实体以初始化一个流。<br>B. 接收实体打开一个TCP连接，发送一个XML流头信息（其’version’属性设置为”1.0”）给初始化实体作为应答。<br>C. 接收实体向初始化实体提议STARTTLS范围（包括其他支持的流特性），如果TLS对于和接收实体交互是必需的，它应该（SHOULD）在<starttls>元素中包含子元素<required><br>D. 初始化实体发出STARTTLS命令(例如, 一个符合’urn:ietf:params:xml:ns:xmpp-tls’名字空间的 <starttls> 元素) 以通知接收实体它希望开始一个TLS握手来保护流。<br>E. 接收实体必须（MUST）以’urn:ietf:params:xml:ns:xmpp-tls’名字空间中的<proceed>元素或<failure>元素应答。如果失败，接收实体必须（MUST）终止XML流和相应的TCP连接。如果继续进行，接收实体必须（MUST）尝试通过TCP连接完成TLS握手并且在TLS握手完成之前不能（MUST NOT）发送任何其他XML数据。<br>F. 初始化实体和接收实体尝试完成TLS握手。（要符合[TLS]规范）<br>G. 如果 TLS 握手不成功, 接收实体必须（MUST）终止 TCP 连接. 如果 TLS 握手成功, 初始化实体必须（MUST）发送给接收实体一个打开的XML流头信息来初始化一个新的流（先发送一个关闭标签是不必要的,因为接收实体和初始化实体必须(MUST)确保原来的流在TLS握手成功之后被关闭） 。<br>H. 在从初始化实体收到新的流头信息之后，接收实体必须（MUST）发送一个新的XML流头信息给初始化实体作为应答，其中应包含可用的特性但不包含STATRTTLS特性。</failure></proceed></starttls></required></starttls></proceed></proceed></starttls></p>
<p><a href="http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html</a></p>
<p>在文章开始，请你了解和熟悉openfire方面的相关知识，这样对你理解下面代码以及下面代码的用途有很好的了解。同时，你可能需要安装一个简单的CS聊天工具，来测试你的代码是否成功的在openfire服务器上建立会话链接，并成功的向在线用户发送聊天消息。<br>必须了解：<a href="http://www.cnblogs.com/hoojo/archive/2012/05/17/2506769.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/05/17/2506769.html</a><br><a href="http://www.cnblogs.com/hoojo/archive/2012/05/13/2498151.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/05/13/2498151.html</a> （非windows 系统）<br>可选：<a href="http://www.cnblogs.com/hoojo/archive/2012/05/17/2506845.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/05/17/2506845.html</a><br><a href="http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html" target="_blank" rel="external">http://www.cnblogs.com/hoojo/archive/2012/06/18/2553975.html</a></p>
<p>聊天软件Spark，用于测试聊天消息发送是否成功，下载地址：<a href="http://www.igniterealtime.org/do" target="_blank" rel="external">http://www.igniterealtime.org/do</a> … ark/spark_2_6_3.exe</p>
<p>然后你需要添加smack相关的jar包<br>smack.jar<br>smackx.jar<br>jar包下载地址：<a href="http://www.igniterealtime.org/do" target="_blank" rel="external">http://www.igniterealtime.org/do</a> … ack/smack_3_2_2.zip<br>代码中还用到了junit，junit jar下载地址：<a href="http://ebr.springsource.com/repo" target="_blank" rel="external">http://ebr.springsource.com/repo</a> … 8.2&amp;type=binary</p>
<p>下面开始代码部分<br>package com.hoo.smack;</p>
<p>import java.util.Collection;<br>import java.util.Iterator;<br>import javax.net.SocketFactory;<br>import org.jivesoftware.smack.AccountManager;<br>import org.jivesoftware.smack.Chat;<br>import org.jivesoftware.smack.ChatManager;<br>import org.jivesoftware.smack.Connection;<br>import org.jivesoftware.smack.ConnectionConfiguration;<br>import org.jivesoftware.smack.MessageListener;<br>import org.jivesoftware.smack.Roster;<br>import org.jivesoftware.smack.RosterEntry;<br>import org.jivesoftware.smack.XMPPConnection;<br>import org.jivesoftware.smack.XMPPException;<br>import org.jivesoftware.smack.packet.Message;<br>import org.jivesoftware.smack.packet.Presence;<br>import org.jivesoftware.smack.packet.Session;<br>import org.jivesoftware.smack.packet.Message.Type;<br>import org.junit.After;<br>import org.junit.Before;<br>import org.junit.Test;</p>
<p>/**</p>
<ul>
<li><b>function:</b> 利用Smack框架完成 XMPP 协议通信</li>
<li>@author hoojo</li>
<li>@createDate 2012-5-22 上午10:28:18</li>
<li>@file ConnectionServerTest.java</li>
<li>@package com.hoo.smack.conn</li>
<li>@project jwchat</li>
<li>@blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank" rel="external">http://blog.csdn.net/IBM_hoojo</a></li>
<li>@email hoojo_@126.com</li>
<li>@version 1.0<br>*/<br>public class SmackXMPPTest {</li>
</ul>
<p>private Connection connection;<br>private ConnectionConfiguration config;<br>/<em>* openfire服务器address </em>/<br>private final static String server = “192.168.8.32”;</p>
<p>private final void fail(Object o) {<br>if (o != null) {<br>System.out.println(o);<br>}<br>}</p>
<p>private final void fail(Object o, Object… args) {<br>if (o != null &amp;&amp; args != null &amp;&amp; args.length &gt; 0) {<br>String s = o.toString();<br>for (int i = 0; i &lt; args.length; i++) {<br>String item = args == null ? “” : args.toString();<br>if (s.contains(“{“ + i + “}”)) {<br>s = s.replace(“{“ + i + “}”, item);<br>} else {<br>s += “ “ + item;<br>}<br>}<br>System.out.println(s);<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> 初始Smack对openfire服务器链接的基本配置</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:06:42<br><em>/<br>@Before<br>public void init() {<br>try {<br>//connection = new XMPPConnection(server);<br>//connection.connect();<br>/** 5222是openfire服务器默认的通信端口，你可以登录<a href="http://192.168.8.32:9090/到管理员控制台查看客户端到服务器端口" target="_blank" rel="external">http://192.168.8.32:9090/到管理员控制台查看客户端到服务器端口</a> </em>/<br>config = new ConnectionConfiguration(server, 5222);</li>
</ul>
<p>/<strong> 是否启用压缩 */<br>config.setCompressionEnabled(true);<br>/</strong> 是否启用安全验证 <em>/<br>config.setSASLAuthenticationEnabled(true);<br>/** 是否启用调试 </em>/<br>config.setDebuggerEnabled(false);<br>//config.setReconnectionAllowed(true);<br>//config.setRosterLoadedAtLogin(true);</p>
<p>/<strong> 创建connection链接 */<br>connection = new XMPPConnection(config);<br>/</strong> 建立连接 */<br>connection.connect();<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>fail(connection);<br>fail(connection.getConnectionID());<br>}</p>
<p>@After<br>public void destory() {<br>if (connection != null) {<br>connection.disconnect();<br>connection = null;<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> ConnectionConfiguration 的基本配置相关信息</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:11:25<br>*/<br>@Test<br>public void testConfig() {<br>fail(“PKCS11Library: “ + config.getPKCS11Library());<br>fail(“ServiceName: {0}”, config.getServiceName());<br>// ssl证书密码<br>fail(“TruststorePassword: {0}”, config.getTruststorePassword());<br>fail(“TruststorePath: {0}”, config.getTruststorePath());<br>fail(“TruststoreType: {0}”, config.getTruststoreType());</li>
</ul>
<p>SocketFactory socketFactory = config.getSocketFactory();<br>fail(“SocketFactory: {0}”, socketFactory);<br>/<em>try {<br>fail(“createSocket: {0}”, socketFactory.createSocket(“localhost”, 3333));<br>} catch (IOException e) {<br>e.printStackTrace();<br>}</em>/<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> Connection 基本方法信息</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:12:04<br><em>/<br>@Test<br>public void testConnection() {<br>/** 用户管理 </em>/<br>AccountManager accountManager = connection.getAccountManager();<br>for (String attr : accountManager.getAccountAttributes()) {<br>fail(“AccountAttribute: {0}”, attr);<br>}<br>fail(“AccountInstructions: {0}”, accountManager.getAccountInstructions());<br>/<strong> 是否链接 */<br>fail(“isConnected:”, connection.isConnected());<br>fail(“isAnonymous:”, connection.isAnonymous());<br>/</strong> 是否有权限 <em>/<br>fail(“isAuthenticated:”, connection.isAuthenticated());<br>fail(“isSecureConnection:”, connection.isSecureConnection());<br>/** 是否使用压缩 </em>/<br>fail(“isUsingCompression:”, connection.isUsingCompression());<br>}</li>
</ul>
<p>/**</p>
<ul>
<li><b>function:</b> 用户管理器</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午04:22:31<br>*/<br>@Test<br>public void testAccountManager() {<br>AccountManager accountManager = connection.getAccountManager();<br>for (String attr : accountManager.getAccountAttributes()) {<br>fail(“AccountAttribute: {0}”, attr);<br>}<br>fail(“AccountInstructions: {0}”, accountManager.getAccountInstructions());</li>
</ul>
<p>fail(“supportsAccountCreation: {0}”, accountManager.supportsAccountCreation());<br>try {<br>/<strong> 创建一个用户boy，密码为boy；你可以在管理员控制台页面<a href="http://192.168.8.32:9090/user-summary.jsp查看用户/组的相关信息，来查看是否成功创建用户" target="_blank" rel="external">http://192.168.8.32:9090/user-summary.jsp查看用户/组的相关信息，来查看是否成功创建用户</a> */<br>accountManager.createAccount(“boy”, “boy”);<br>/</strong> 修改密码 */<br>accountManager.changePassword(“abc”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>}</p>
<p>@Test<br>public void testUser() {<br>try {<br>/<strong> 用户登陆，用户名、密码 */<br>connection.login(“hoojo”, “hoojo”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>/</strong> 获取当前登陆用户 */<br>fail(“User:”, connection.getUser());</p>
<p>/<em>* 所有用户组 </em>/<br>Roster roster = connection.getRoster();</p>
<p>/<em>* 好友用户组，你可以用Spark添加用户好友，这样这里就可以查询到相关的数据 </em>/<br>Collection<rosterentry> rosterEntiry = roster.getEntries();<br>Iterator<rosterentry> iter = rosterEntiry.iterator();<br>while (iter.hasNext()) {<br>RosterEntry entry = iter.next();<br>fail(“Groups: {0}, Name: {1}, Status: {2}, Type: {3}, User: {4}”, entry.getGroups(), entry.getName(), entry.getStatus(), entry.getType(), entry);<br>}</rosterentry></rosterentry></p>
<p>fail(“——————————-“);<br>/<em>* 未处理、验证好友，添加过的好友，没有得到对方同意 </em>/<br>Collection<rosterentry> unfiledEntries = roster.getUnfiledEntries();<br>iter = unfiledEntries.iterator();<br>while (iter.hasNext()) {<br>RosterEntry entry = iter.next();<br>fail(“Groups: {0}, Name: {1}, Status: {2}, Type: {3}, User: {4}”, entry.getGroups(), entry.getName(), entry.getStatus(), entry.getType(), entry);<br>}<br>}</rosterentry></p>
<p>@Test<br>@SuppressWarnings(“static-access”)<br>public void testPacket() {<br>try {<br>connection.login(“hoojo”, “hoojo”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}</p>
<p>//Packet packet = new Data(new DataPacketExtension(“jojo@” + server, 2, “this is a message”));<br>//connection.sendPacket(packet);</p>
<p>/<em>* 更改用户状态，available=true表示在线，false表示离线，status状态签名；当你登陆后，在Spark客户端软件中就可以看到你登陆的状态 </em>/<br>Presence presence = new Presence(Presence.Type.available);<br>presence.setStatus(“Q我吧”);<br>connection.sendPacket(presence);</p>
<p>Session session = new Session();<br>String sessid = session.nextID();<br>connection.sendPacket(session);<br>/** 向jojo@192.168.8.32 发送聊天消息，此时你需要用Spark软件登陆jojo这个用户，</p>
<ul>
<li>这样代码就可以向jojo这个用户发送聊天消息，Spark登陆的jojo用户就可以接收到消息<br><strong>/<br>/</strong> Type.chat 表示聊天，groupchat多人聊天，error错误，headline在线用户； */<br>Message message = new Message(“jojo@” + server, Type.chat);<br>//Message message = new Message(sessid, Type.chat);<br>message.setBody(“h!~ jojo, I’am is hoojo!”);<br>connection.sendPacket(message);</li>
</ul>
<p>try {<br>Thread.sleep(1);<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> 测试聊天消息管理类</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午05:03:23<br><em>/<br>@Test<br>public void testChatManager() {<br>/** 设置状态 </em>/<br>try {<br>connection.login(“hoojo”, “hoojo”);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}</li>
</ul>
<p>/<em>* 设置状态 </em>/<br>Presence presence = new Presence(Presence.Type.available);<br>presence.setStatus(“Q我吧”);<br>connection.sendPacket(presence);</p>
<p>/<strong> 获取当前登陆用户的聊天管理器 */<br>ChatManager chatManager = connection.getChatManager();<br>/</strong> 为指定用户创建一个chat，MyMessageListeners用于监听对方发过来的消息  <em>/<br>Chat chat = chatManager.createChat(“jojo@” + server, new MyMessageListeners());<br>try {<br>/** 发送消息 </em>/<br>chat.sendMessage(“h!~ jojo……”);</p>
<p>/<em>* 用message对象发送消息 </em>/<br>Message message = new Message();<br>message.setBody(“message”);<br>message.setProperty(“color”, “red”);<br>chat.sendMessage(message);<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>try {<br>Thread.sleep(1000 * 1000);<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}</p>
<p>/**</p>
<ul>
<li><b>function:</b> 消息监听器，用户监听对方发送的消息，也可以想对方发送消息</li>
<li>@author hoojo</li>
<li>@createDate 2012-6-25 下午05:05:31</li>
<li>@file SmackXMPPTest.java</li>
<li>@package com.hoo.smack</li>
<li>@project jwchat</li>
<li>@blog <a href="http://blog.csdn.net/IBM_hoojo" target="_blank" rel="external">http://blog.csdn.net/IBM_hoojo</a></li>
<li>@email hoojo_@126.com</li>
<li>@version 1.0<br><em>/<br>class MyMessageListeners implements MessageListener {<br>public void processMessage(Chat chat, Message message) {<br>try {<br>/** 发送消息 </em>/<br>chat.sendMessage(“dingding……” + message.getBody());<br>} catch (XMPPException e) {<br>e.printStackTrace();<br>}<br>/<em>* 接收消息 </em>/<br>fail(“From: {0}, To: {1}, Type: {2}, Sub: {3}”, message.getFrom(), message.getTo(), message.getType(), message.toXML());<br>/<em>Collection<body> bodys =  message.getBodies();<br>for (Body body : bodys) {<br>fail(“bodies[{0}]”, body.getMessage());<br>}<br>//fail(message.getLanguage());<br>//fail(message.getThread());<br>//fail(message.getXmlns());</body></em>/<br>fail(“body: “, message.getBody());<br>}<br>}<br>}<br>好了，这些都是smack的基本功能，还有更多的东西需要研究，下次有机会再分享！</li>
</ul>
<p></p>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2016/02/13/ios-xmpp协议/">
    <time datetime="2016-02-12T17:29:11.000Z" class="entry-date">
        2016-02-13
    </time>
</a>
    
    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ios/">ios</a></li></ul>

    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
    
        <span class="nav-next"><a href="/2015/11/17/ios-加密方式/" rel="next">ios-加密方式 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2016/02/13/ios-xmpp协议/">ios-xmpp协议</a>
          </li>
        
          <li>
            <a href="/2015/11/17/ios-加密方式/">ios-加密方式</a>
          </li>
        
          <li>
            <a href="/2015/06/23/ios-Runtime机制/">ios-Runtime机制</a>
          </li>
        
          <li>
            <a href="/2015/06/16/ios页面跳转机制/">ios页面跳转机制</a>
          </li>
        
          <li>
            <a href="/2014/07/15/nonatomic、-synthesize、-property、-dynamic/">关键字介绍：nonatomic、@synthesize、@property、@dynamic</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-content">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ios/">ios</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/iOS/" style="font-size: 10px;">iOS</a> <a href="/tags/ios/" style="font-size: 10px;">ios</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2016 小俊
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
</body>
</html>